<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[BridgeQ的个人学习博客]]></title>
  <link href="http://wxgbridgeq.github.io/atom.xml" rel="self"/>
  <link href="http://wxgbridgeq.github.io/"/>
  <updated>2018-09-26T22:53:03+08:00</updated>
  <id>http://wxgbridgeq.github.io/</id>
  <author>
    <name><![CDATA[BridgeQ]]></name>
    <email><![CDATA[wxg.bridgeq@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自定义控制器转场动画及下拉菜单的小Demo | AppCoda翻译系列]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/08/10/custom-transition-animation/"/>
    <updated>2015-08-10T22:19:36+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/08/10/custom-transition-animation</id>
    <content type="html"><![CDATA[<p>本文翻译总结自AppCoda以下两篇文章：</p>

<ul>
<li><a href="http://www.appcoda.com/custom-view-controller-transitions-tutorial/">Introduction to Custom View Controller Transitions and Animations</a></li>
<li><a href="http://www.appcoda.com/slide-down-menu-swift/">Creating a Slide Down Menu Using View Controller Transition</a></li>
</ul>


<p>iOS 7开始，苹果为开发者提供了自定义控制器转场动画相关的API，而实现该功能需要以下三个步骤：</p>

<ul>
<li>创建一个类作为动画管理器，该类需继承自NSObject并遵守UIViewControllerAnimatedTransitioning协议，我们在这个类中编写我们的动画执行代码。</li>
<li>为目标控制器指定转场动画代理，既可以使用上一步创建的动画管理器对象，也可以指定来源控制器作为这个代理。</li>
<li>实现代理协议中的相应方法，在方法中返回第一步创建的动画管理器对象。</li>
</ul>


<!--more-->


<h2>准备工作</h2>

<p>下载示例程序，地址在<a href="https://www.dropbox.com/s/4p6kk0g3qua1kvt/CustomTransitionsStarter.zip?dl=0">这里</a>。（译注：原文地址需要FQ访问，本人已转存到GitHub上，点击<a href="https://github.com/WXGBridgeQ/CustomTransitions">这里</a>。）</p>

<p>示例程序如下图所示，点击导航栏上的Action按钮会modal出一个目标控制器，点击Dismiss按钮会返回来源控制器，只不过现在使用的是系统默认的modal动画，接下来我们就来实现自定义转场动画。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid01.gif" alt="" /></p>

<h2>创建动画管理器</h2>

<p>创建一个类名称为CustomPresentAnimationController，继承自NSObject并遵守UIViewControllerAnimatedTransitioning协议。这个协议有两个必须实现的方法，我们的实现代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">transitionDuration</span><span class="p">(</span><span class="nl">transitionContext</span><span class="p">:</span> <span class="bp">UIViewControllerContextTransitioning</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NSTimeInterval</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="mf">2.5</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">animateTransition</span><span class="p">(</span><span class="nl">transitionContext</span><span class="p">:</span> <span class="bp">UIViewControllerContextTransitioning</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">let</span> <span class="n">fromViewController</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">viewControllerForKey</span><span class="p">(</span><span class="n">UITransitionContextFromViewControllerKey</span><span class="p">)</span><span class="o">!</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">toViewController</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">viewControllerForKey</span><span class="p">(</span><span class="n">UITransitionContextToViewControllerKey</span><span class="p">)</span><span class="o">!</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">finalFrameForVC</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">finalFrameForViewController</span><span class="p">(</span><span class="n">toViewController</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">containerView</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">containerView</span><span class="p">()</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">bounds</span> <span class="o">=</span> <span class="bp">UIScreen</span><span class="p">.</span><span class="n">mainScreen</span><span class="p">().</span><span class="n">bounds</span>
</span><span class='line'>    <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectOffset</span><span class="p">(</span><span class="n">finalFrameForVC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
</span><span class='line'>    <span class="n">containerView</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="n">transitionDuration</span><span class="p">(</span><span class="n">transitionContext</span><span class="p">),</span> <span class="nl">delay</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">usingSpringWithDamping</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nl">initialSpringVelocity</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">options</span><span class="p">:</span> <span class="p">.</span><span class="n">CurveLinear</span><span class="p">,</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
</span><span class='line'>        <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">finalFrameForVC</span>
</span><span class='line'>        <span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">finished</span> <span class="k">in</span>
</span><span class='line'>            <span class="n">transitionContext</span><span class="p">.</span><span class="n">completeTransition</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span><span class='line'>            <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个方法很简单，设定动画执行时间。第二个方法则用来编写我们自定义的动画代码，在这个方法中我们可以利用transitionContext（转场上下文）来获得我们将来的来源控制器、目标控制器、动画完成后的最终frame，还可以获得用来管理来源或目标视图的容器视图。</p>

<p>然后我们将目标视图调整到屏幕下方并将其添加到容器视图内。接下来在动画执行的闭包内，将目标视图的位置变为最终位置，并将来源视图的透明度降为0.5，使其在目标视图进入的过程中产生一个淡出的效果。在动画完成的闭包内，我们告知transitionContext动画已完成，并将来源视图的透明度改回1.0。</p>

<h2>设置转场动画代理</h2>

<p>接下来我们需要为目标控制器设置转场动画代理，这里我们指定来源控制器作为我们的代理。在ItemsTableViewController中，让其遵守UIViewControllerTransitioningDelegate协议，在storyboard中找到我们modal的segue，设置它的Identifier为showAction。然后在ItemsTableViewController中添加如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">customPresentAnimationController</span> <span class="o">=</span> <span class="n">CustomPresentAnimationController</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">override</span> <span class="n">func</span> <span class="n">prepareForSegue</span><span class="p">(</span><span class="nl">segue</span><span class="p">:</span> <span class="bp">UIStoryboardSegue</span><span class="p">,</span> <span class="nl">sender</span><span class="p">:</span> <span class="n">AnyObject</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="n">segue</span><span class="p">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="s">&quot;showAction&quot;</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">toViewController</span> <span class="o">=</span> <span class="n">segue</span><span class="p">.</span><span class="n">destinationViewController</span> <span class="n">as</span> <span class="bp">UIViewController</span>
</span><span class='line'>        <span class="n">toViewController</span><span class="p">.</span><span class="n">transitioningDelegate</span> <span class="o">=</span> <span class="nb">self</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">animationControllerForPresentedController</span><span class="p">(</span><span class="nl">presented</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="n">presentingController</span> <span class="nl">presenting</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="n">sourceController</span> <span class="nl">source</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">UIViewControllerAnimatedTransitioning</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">customPresentAnimationController</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们创建了一个动画管理器对象，设置目标控制器的转场代理为来源控制器，然后实现代理协议中的animationControllerForPresentedController方法，该方法用于指定modal过程中展示视图的动画，在该方法中返回我们自定义的动画管理器对象。</p>

<p>运行我们的程序，效果如下图所示：</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid02.gif" alt="" /></p>

<p>跟系统默认modal效果差不多，不过带有弹簧效果。如果你希望有不同的效果，你可以对下面这句代码进行修改。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectOffset</span><span class="p">(</span><span class="n">finalFrameForVC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>比如将其改为如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectOffset</span><span class="p">(</span><span class="n">finalFrameForVC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>再次运行程序，我们的modal动画就变为从上往下了。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid03.gif" alt="" /></p>

<h2>自定义modal过程中退出视图的动画</h2>

<p>我们的程序现在点击Dismiss退出目标控制器时，仍然是系统默认的动画，接下来实现这个自定义动画。</p>

<p>步骤同前面基本一样，创建一个叫做CustomDismissAnimationController的动画管理器，实现如下代理方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">transitionDuration</span><span class="p">(</span><span class="nl">transitionContext</span><span class="p">:</span> <span class="bp">UIViewControllerContextTransitioning</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NSTimeInterval</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">2</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">animateTransition</span><span class="p">(</span><span class="nl">transitionContext</span><span class="p">:</span> <span class="bp">UIViewControllerContextTransitioning</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">fromViewController</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">viewControllerForKey</span><span class="p">(</span><span class="n">UITransitionContextFromViewControllerKey</span><span class="p">)</span><span class="o">!</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">toViewController</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">viewControllerForKey</span><span class="p">(</span><span class="n">UITransitionContextToViewControllerKey</span><span class="p">)</span><span class="o">!</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">finalFrameForVC</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">finalFrameForViewController</span><span class="p">(</span><span class="n">toViewController</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">containerView</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">containerView</span><span class="p">()</span>
</span><span class='line'>    <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">finalFrameForVC</span>
</span><span class='line'>    <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
</span><span class='line'>    <span class="n">containerView</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">)</span>
</span><span class='line'>    <span class="n">containerView</span><span class="p">.</span><span class="n">sendSubviewToBack</span><span class="p">(</span><span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="n">transitionDuration</span><span class="p">(</span><span class="n">transitionContext</span><span class="p">),</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectInset</span><span class="p">(</span><span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span>
</span><span class='line'>    <span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">finished</span> <span class="k">in</span>
</span><span class='line'>        <span class="n">transitionContext</span><span class="p">.</span><span class="n">completeTransition</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这次我们使用一个新的动画方式，让来源视图从中心点开始逐渐变小直到消失。首先我们将目标控制器设置为最终位置，透明度为0.5，并将其添加到容器视图的底层中使其开始时不可见。在动画执行过程中，来源视图逐渐变小，露出底层的目标视图，并将目标视图透明度过渡到1.0。</p>

<p>接下来在ItemsTableViewController中添加如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">customDismissAnimationController</span> <span class="o">=</span> <span class="n">CustomDismissAnimationController</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">animationControllerForDismissedController</span><span class="p">(</span><span class="nl">dismissed</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">UIViewControllerAnimatedTransitioning</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">customDismissAnimationController</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>animationControllerForDismissedController这个代理方法指定了modal过程中退出视图的动画。运行程序，你会发现我们的动画有点小Bug。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid05.gif" alt="" /></p>

<p>我们可以看到，白色的背景视图确实如我们所愿从中心点逐渐缩小，但是图片视图的大小却保持不变，这是因为改变来源视图的时候，它的子控件的大小并不会跟着发生改变，我们可以通过视图快照的技术来解决这一问题。</p>

<p>将animateTransition方法的实现修改为如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">animateTransition</span><span class="p">(</span><span class="nl">transitionContext</span><span class="p">:</span> <span class="bp">UIViewControllerContextTransitioning</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">fromViewController</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">viewControllerForKey</span><span class="p">(</span><span class="n">UITransitionContextFromViewControllerKey</span><span class="p">)</span><span class="o">!</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">toViewController</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">viewControllerForKey</span><span class="p">(</span><span class="n">UITransitionContextToViewControllerKey</span><span class="p">)</span><span class="o">!</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">finalFrameForVC</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">finalFrameForViewController</span><span class="p">(</span><span class="n">toViewController</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">containerView</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">containerView</span><span class="p">()</span>
</span><span class='line'>    <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">finalFrameForVC</span>
</span><span class='line'>    <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
</span><span class='line'>    <span class="n">containerView</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">)</span>
</span><span class='line'>    <span class="n">containerView</span><span class="p">.</span><span class="n">sendSubviewToBack</span><span class="p">(</span><span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">let</span> <span class="n">snapshotView</span> <span class="o">=</span> <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">snapshotViewAfterScreenUpdates</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
</span><span class='line'>    <span class="n">snapshotView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span>
</span><span class='line'>    <span class="n">containerView</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">snapshotView</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">removeFromSuperview</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="n">transitionDuration</span><span class="p">(</span><span class="n">transitionContext</span><span class="p">),</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">snapshotView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectInset</span><span class="p">(</span><span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span>
</span><span class='line'>    <span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">finished</span> <span class="k">in</span>
</span><span class='line'>        <span class="n">snapshotView</span><span class="p">.</span><span class="n">removeFromSuperview</span><span class="p">()</span>
</span><span class='line'>        <span class="n">transitionContext</span><span class="p">.</span><span class="n">completeTransition</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们给来源视图生成了一个快照，将它添加到容器视图中利用它来做动画，并将来源视图从父控件中移除。再次运行程序，我们的动画效果就正常了。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid06.gif" alt="" /></p>

<h2>导航控制器的转场动画</h2>

<p>在UITabBarController和UINavigationController的管理下，你无需为每个目标控制器都设置转场代理，可以直接设置UITabBarControllerDelegate或UINavigationControllerDelegate即可。</p>

<p>接下来我们演示如何为导航控制器设置自定义转场动画。首先，仍然是创建一个动画管理器类叫做CustomNavigationAnimationController，然后实现UIViewControllerAnimatedTransitioning协议的方法。这里的动画代码采用的是一个开源的三维旋转动画，读者可以到<a href="https://github.com/andresbrun/ABCustomUINavigationController#cube">这里</a>自行研究。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">reverse</span><span class="p">:</span> <span class="n">Bool</span> <span class="o">=</span> <span class="nb">false</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">transitionDuration</span><span class="p">(</span><span class="nl">transitionContext</span><span class="p">:</span> <span class="bp">UIViewControllerContextTransitioning</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NSTimeInterval</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="mf">1.5</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">animateTransition</span><span class="p">(</span><span class="nl">transitionContext</span><span class="p">:</span> <span class="bp">UIViewControllerContextTransitioning</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">containerView</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">containerView</span><span class="p">()</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">toViewController</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">viewControllerForKey</span><span class="p">(</span><span class="n">UITransitionContextToViewControllerKey</span><span class="p">)</span><span class="o">!</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">fromViewController</span> <span class="o">=</span> <span class="n">transitionContext</span><span class="p">.</span><span class="n">viewControllerForKey</span><span class="p">(</span><span class="n">UITransitionContextFromViewControllerKey</span><span class="p">)</span><span class="o">!</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">toView</span> <span class="o">=</span> <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">fromView</span> <span class="o">=</span> <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">direction</span><span class="p">:</span> <span class="n">CGFloat</span> <span class="o">=</span> <span class="n">reverse</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">let</span> <span class="k">const</span><span class="o">:</span> <span class="n">CGFloat</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.005</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">toView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</span><span class='line'>    <span class="n">fromView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">var</span> <span class="nl">viewFromTransform</span><span class="p">:</span> <span class="bp">CATransform3D</span> <span class="o">=</span> <span class="n">CATransform3DMakeRotation</span><span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">CGFloat</span><span class="p">(</span><span class="n">M_PI_2</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">viewToTransform</span><span class="p">:</span> <span class="bp">CATransform3D</span> <span class="o">=</span> <span class="n">CATransform3DMakeRotation</span><span class="p">(</span><span class="o">-</span><span class="n">direction</span> <span class="o">*</span> <span class="n">CGFloat</span><span class="p">(</span><span class="n">M_PI_2</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">viewFromTransform</span><span class="p">.</span><span class="n">m34</span> <span class="o">=</span> <span class="k">const</span>
</span><span class='line'>    <span class="n">viewToTransform</span><span class="p">.</span><span class="n">m34</span> <span class="o">=</span> <span class="k">const</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">containerView</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformMakeTranslation</span><span class="p">(</span><span class="n">direction</span> <span class="o">*</span> <span class="n">containerView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">toView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">viewToTransform</span>
</span><span class='line'>    <span class="n">containerView</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">toView</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="n">transitionDuration</span><span class="p">(</span><span class="n">transitionContext</span><span class="p">),</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">containerView</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformMakeTranslation</span><span class="p">(</span><span class="o">-</span><span class="n">direction</span> <span class="o">*</span> <span class="n">containerView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">fromView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">viewFromTransform</span>
</span><span class='line'>        <span class="n">toView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DIdentity</span>
</span><span class='line'>    <span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">finished</span> <span class="k">in</span>
</span><span class='line'>        <span class="n">containerView</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformIdentity</span>
</span><span class='line'>        <span class="n">fromView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DIdentity</span>
</span><span class='line'>        <span class="n">toView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DIdentity</span>
</span><span class='line'>        <span class="n">fromView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</span><span class='line'>        <span class="n">toView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">transitionContext</span><span class="p">.</span><span class="n">transitionWasCancelled</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">toView</span><span class="p">.</span><span class="n">removeFromSuperview</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">fromView</span><span class="p">.</span><span class="n">removeFromSuperview</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">transitionContext</span><span class="p">.</span><span class="n">completeTransition</span><span class="p">(</span><span class="o">!</span><span class="n">transitionContext</span><span class="p">.</span><span class="n">transitionWasCancelled</span><span class="p">())</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意这里我们添加了一个reverse变量，用来指定转场动画的方向，这样我们可以将导航控制器push和pop过程的动画封装在一个动画管理器中。</p>

<p>在ItemsTableViewController中更改它的声明使其遵守UINavigationControllerDelegate协议，在viewDidLoad方法中设置代理为自己<code>navigationController?.delegate = self</code>，然后添加如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">customNavigationAnimationController</span> <span class="o">=</span> <span class="n">CustomNavigationAnimationController</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">navigationController</span><span class="p">(</span><span class="nl">navigationController</span><span class="p">:</span> <span class="bp">UINavigationController</span><span class="p">,</span> <span class="n">animationControllerForOperation</span> <span class="nl">operation</span><span class="p">:</span> <span class="n">UINavigationControllerOperation</span><span class="p">,</span> <span class="n">fromViewController</span> <span class="nl">fromVC</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="n">toViewController</span> <span class="nl">toVC</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">UIViewControllerAnimatedTransitioning</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">customNavigationAnimationController</span><span class="p">.</span><span class="n">reverse</span> <span class="o">=</span> <span class="n">operation</span> <span class="o">==</span> <span class="p">.</span><span class="n">Pop</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">customNavigationAnimationController</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这个导航控制器的代理方法用于指定push或pop时的转场动画，其中operation参数可以用来判断转场的方向。运行程序，如下图所示：</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid07.gif" alt="" /></p>

<h2>导航控制器的手势交互</h2>

<p>我们知道苹果官方为导航控制器添加了一个默认的手势交互，就是在屏幕左侧向右滑动可以返回上一界面并带有pop动画，接下来我们为我们的自定义动画添加手势交互。</p>

<p>手势交互的管理器需要遵守的是UIViewControllerInteractiveTransitioning协议，该协议需要实现startInteractiveTransition方法指定开始交互，不过苹果官方为我们提供了另一个已经实现该协议的交互管理器类UIPercentDrivenInteractiveTransition，并提供以百分比的形式来控制交互过程的功能，比如控制交互的更新、取消、完成等，我们直接使用它来实现我们的交互控制。</p>

<p>创建一个类叫做CustomInteractionController并继承自UIPercentDrivenInteractiveTransition，添加如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">navigationController</span><span class="p">:</span> <span class="bp">UINavigationController</span><span class="o">!</span>
</span><span class='line'><span class="n">var</span> <span class="n">shouldCompleteTransition</span> <span class="o">=</span> <span class="nb">false</span>
</span><span class='line'><span class="n">var</span> <span class="n">transitionInProgress</span> <span class="o">=</span> <span class="nb">false</span>
</span><span class='line'><span class="n">var</span> <span class="nl">completionSeed</span><span class="p">:</span> <span class="n">CGFloat</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">percentComplete</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">attachToViewController</span><span class="p">(</span><span class="nl">viewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">navigationController</span> <span class="o">=</span> <span class="n">viewController</span><span class="p">.</span><span class="n">navigationController</span>
</span><span class='line'>    <span class="n">setupGestureRecognizer</span><span class="p">(</span><span class="n">viewController</span><span class="p">.</span><span class="n">view</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">private</span> <span class="n">func</span> <span class="n">setupGestureRecognizer</span><span class="p">(</span><span class="nl">view</span><span class="p">:</span> <span class="bp">UIView</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">view</span><span class="p">.</span><span class="n">addGestureRecognizer</span><span class="p">(</span><span class="bp">UIPanGestureRecognizer</span><span class="p">(</span><span class="nl">target</span><span class="p">:</span> <span class="nb">self</span><span class="p">,</span> <span class="nl">action</span><span class="p">:</span> <span class="s">&quot;handlePanGesture:&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="n">handlePanGesture</span><span class="p">(</span><span class="nl">gestureRecognizer</span><span class="p">:</span> <span class="bp">UIPanGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">viewTranslation</span> <span class="o">=</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">translationInView</span><span class="p">(</span><span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">view</span><span class="o">!</span><span class="p">.</span><span class="n">superview</span><span class="o">!</span><span class="p">)</span>
</span><span class='line'>    <span class="k">switch</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">state</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="nl">Began</span><span class="p">:</span>
</span><span class='line'>        <span class="n">transitionInProgress</span> <span class="o">=</span> <span class="nb">true</span>
</span><span class='line'>        <span class="n">navigationController</span><span class="p">.</span><span class="n">popViewControllerAnimated</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="nl">Changed</span><span class="p">:</span>
</span><span class='line'>        <span class="n">var</span> <span class="k">const</span> <span class="o">=</span> <span class="n">CGFloat</span><span class="p">(</span><span class="n">fminf</span><span class="p">(</span><span class="n">fmaxf</span><span class="p">(</span><span class="n">Float</span><span class="p">(</span><span class="n">viewTranslation</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="mf">200.0</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">))</span>
</span><span class='line'>        <span class="n">shouldCompleteTransition</span> <span class="o">=</span> <span class="k">const</span> <span class="o">&gt;</span> <span class="mf">0.5</span>
</span><span class='line'>        <span class="n">updateInteractiveTransition</span><span class="p">(</span><span class="k">const</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="n">Cancelled</span><span class="p">,</span> <span class="p">.</span><span class="nl">Ended</span><span class="p">:</span>
</span><span class='line'>        <span class="n">transitionInProgress</span> <span class="o">=</span> <span class="nb">false</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">!</span><span class="n">shouldCompleteTransition</span> <span class="o">||</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="p">.</span><span class="n">Cancelled</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">cancelInteractiveTransition</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">finishInteractiveTransition</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="k">default</span><span class="o">:</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Swift switch must be exhaustive, thus the default&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>attachToViewController方法用于将来传入导航控制器的目标控制器，我们为目标控制器的整个view添加了滑动手势以便将来可以实现滑动返回的pop动画，在监听手势滑动的方法中，我们根据手势的状态做如下处理：</p>

<ul>
<li>开始滑动：设置transitionInProgress为true，并开始执行导航控制器的pop返回。</li>
<li>滑动过程中：更新交互过程的百分比，我们假设指定滑动200点即为交互完成。</li>
<li>取消或结束：设置transitionInProgress为false，如果交互过程执行50%以上则认为交互完成。</li>
</ul>


<p>接来下来到我们的ItemsTableViewController，添加如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">customInteractionController</span> <span class="o">=</span> <span class="n">CustomInteractionController</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后修改我们之前实现的导航控制器的代理方法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">navigationController</span><span class="p">(</span><span class="nl">navigationController</span><span class="p">:</span> <span class="bp">UINavigationController</span><span class="p">,</span> <span class="n">animationControllerForOperation</span> <span class="nl">operation</span><span class="p">:</span> <span class="n">UINavigationControllerOperation</span><span class="p">,</span> <span class="n">fromViewController</span> <span class="nl">fromVC</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="n">toViewController</span> <span class="nl">toVC</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">UIViewControllerAnimatedTransitioning</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="p">.</span><span class="n">Push</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">customInteractionController</span><span class="p">.</span><span class="n">attachToViewController</span><span class="p">(</span><span class="n">toVC</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">customNavigationAnimationController</span><span class="p">.</span><span class="n">reverse</span> <span class="o">=</span> <span class="n">operation</span> <span class="o">==</span> <span class="p">.</span><span class="n">Pop</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">customNavigationAnimationController</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们push一个目标控制器时，就为该目标控制器设定交互控制。最后实现导航控制器代理中的另一个方法用于指定交互控制器，代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">navigationController</span><span class="p">(</span><span class="nl">navigationController</span><span class="p">:</span> <span class="bp">UINavigationController</span><span class="p">,</span> <span class="n">interactionControllerForAnimationController</span> <span class="nl">animationController</span><span class="p">:</span> <span class="bp">UIViewControllerAnimatedTransitioning</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">UIViewControllerInteractiveTransitioning</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">customInteractionController</span><span class="p">.</span><span class="n">transitionInProgress</span> <span class="o">?</span> <span class="nl">customInteractionController</span> <span class="p">:</span> <span class="nb">nil</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行程序，如下图所示：</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid09.gif" alt="" /></p>

<p>完整的示例程序链接地址请点击<a href="https://github.com/appcoda/CustomViewTransitionDemo">这里</a>。</p>

<p>推荐阅读：</p>

<ul>
<li><a href="http://objccn.io/issue-12-3/">objc中国：自定义 ViewController 容器转场</a></li>
<li><a href="http://onevcat.com/2013/10/vc-transition-in-ios7/">喵神的好文：WWDC 2013 Session笔记 - iOS7中的ViewController切换</a></li>
</ul>


<h2>实现下拉菜单的小Demo</h2>

<p>Demo实现效果如下图所示，下载完整的Demo代码请点击<a href="https://www.dropbox.com/s/yxxuidy9veqiva8/SlideMenu.zip?dl=0">这里</a>。（译注：原文地址需要FQ访问，本人已转存到GitHub上，点击<a href="https://github.com/WXGBridgeQ/CustomTransitions">这里</a>。）</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/07/slide-down-menu-optimize.gif" alt="" /></p>

<p>实现过程同我们前面讲的自定义转场动画过程一样，首先创建一个动画管理器类MenuTransitionManager，然后设置目标控制器的转场代理，这次我们使用动画管理器对象作为代理，所以MenuTransitionManager既遵守了UIViewControllerAnimatedTransitioning协议，也遵守了UIViewControllerTransitioningDelegate协议。动画的执行代码比较简单，只是通过改变transform控制来源和目标视图的上下移动，目标视图我们仍然使用了快照技术。</p>

<p>我们还为来源视图的快照添加了一个点击的手势，这样在显示下拉菜单后，除了点击相应的菜单选项，点击下部的快照也可以返回到主页视图。只不过点击手势的处理我们使用了代理设计模式，而点击手势的添加我们使用了Swift的属性观察器语法，读者可以自行研究学习。</p>

<p>最后，希望大家学的愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简单模仿iPad版QQ空间界面的小Demo]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/08/09/simple-qzone/"/>
    <updated>2015-08-09T22:50:00+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/08/09/simple-qzone</id>
    <content type="html"><![CDATA[<p>学习iPad开发的第一个小程序，主要学习横竖屏切换时控件frame的更新，以及iPad中modal控制器的样式设置等。</p>

<p>没有太多新知识点，也算是对之前iPhone项目开发的总结回顾吧。</p>

<p>代码思路清晰，注释详尽，适合给新手学习参考。</p>

<p>代码链接地址:<a href="https://github.com/WXGBridgeQ/WXGSimpleQzoneDemo_iPad">WXGSimpleQzoneDemo_iPad</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一次关于OC运行时和Method Swizzing的小实践]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/07/23/oc-runtime-practice/"/>
    <updated>2015-07-23T00:35:28+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/07/23/oc-runtime-practice</id>
    <content type="html"><![CDATA[<h2>起因</h2>

<p>最近练习一个项目，经典的UITabBarController加UINavigationController的组合，茫茫多得页面需要设置一个统一的背景色，起初在每个控制器的viewDidLoad方法中都加上这么一段：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="n">WXGGlobalBackgroundColor</span><span class="p">;</span> <span class="c1">// 设置全局背景色</span>
</span></code></pre></td></tr></table></div></figure>


<p>可是随着开发的进行，控制器和界面越来越多，每一个控制器都要写这么一句同样的代码让我感觉很烦，于是开始寻找一劳永逸的办法。经旁人指点，这其实跟我们想要黑盒测试一个方法一样，不管控制器的viewDidLoad方法做了什么，最后都给他加上设置背景色的代码就OK了。于是马上想到用OC运行时中的Method Swizzing来搞。</p>

<!--more-->


<h2>经过</h2>

<p>有了解决问题的思路，剩下的事就很简单了。我就直接贴代码了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// UIViewController+Extension.h</span>
</span><span class='line'><span class="cp">#import &lt;UIKit/UIKit.h&gt;</span>
</span><span class='line'><span class="k">@interface</span> <span class="bp">UIViewController</span> <span class="nl">(Extension)</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// UIViewController+Extension.m</span>
</span><span class='line'><span class="cp">#import &quot;UIViewController+Extension.h&quot;</span>
</span><span class='line'><span class="cp">#import &lt;objc/runtime.h&gt;</span>
</span><span class='line'><span class="k">@implementation</span> <span class="bp">UIViewController</span> <span class="nl">(Extension)</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">viewDidLoad</span><span class="p">));</span>
</span><span class='line'>        <span class="n">Method</span> <span class="n">swizzledMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">swizzled_viewDidLoad</span><span class="p">));</span>
</span><span class='line'>        <span class="kt">BOOL</span> <span class="n">didAddMethod</span> <span class="o">=</span> <span class="n">class_addMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">viewDidLoad</span><span class="p">),</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">));</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">didAddMethod</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">class_replaceMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">swizzled_viewDidLoad</span><span class="p">),</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">));</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="n">swizzledMethod</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">swizzled_viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="n">swizzled_viewDidLoad</span><span class="p">];</span>
</span><span class='line'><span class="c1">//    self.view.backgroundColor = WXGGlobalBackgroundColor;</span>
</span><span class='line'><span class="c1">//    NSLog(@&quot;%@ loaded&quot;, self);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="nb">self</span> <span class="nl">isKindOfClass</span><span class="p">:</span><span class="n">NSClassFromString</span><span class="p">(</span><span class="s">@&quot;UIInputWindowController&quot;</span><span class="p">)])</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="n">WXGGlobalBackgroundColor</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于Method Swizzing的使用和最佳实践，还是推荐去看Mattt大神的文章吧，链接在<a href="http://nshipster.com/method-swizzling/">这里</a>，英文不好的同学可以看南峰子前辈翻译好的，文章链接在<a href="http://southpeak.github.io/blog/2014/11/06/objective-c-runtime-yun-xing-shi-zhi-si-:method-swizzling/">这里</a>。</p>

<p>Method Swizzing的用法并不难，我就不过多解释了。说一下碰到的问题：第一次写完测试运行的时候，发现模拟器整个界面只有纯色一片，看不到任何控件，进调试工具一看，所有控件都在也都正常，而且在模拟器上点击对应控件的位置，仍然能够触发事件，整个界面就好像被人为涂了一层颜色一样。一时不知该怎么解决，只好NSLog一下，看看都有哪些控制器触发了viewDidLoad方法，然后就真的发现了一个奇怪的家伙：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 省略上面的输出结果</span>
</span><span class='line'><span class="o">&lt;</span><span class="nl">UIInputWindowController</span><span class="p">:</span> <span class="mh">0x7f8a54060400</span><span class="o">&gt;</span> <span class="n">loaded</span>
</span></code></pre></td></tr></table></div></figure>


<p>而且这个家伙还是在最后一个，顿时对它怀疑大增，弄不好就是这家伙弄了个全屏的view给我涂在了屏幕上面。接下来就测试一下是不是它搞的鬼，代码同上面的最终代码，最后测试运行发现排除掉它之后界面立马正常了，真的就是它搞的鬼。</p>

<h2>结果</h2>

<p>最后只能去查这个<em>UIInputWindowController</em>到底是个什么东西，可惜没有查到直接的结果，只知道它是一个苹果的私有API，而且网上已经有人用运行时技术列出了它所包含的成员变量和方法。至于它到底是做什么用的，我们可以从它的命名大致猜一下，多少应该是跟键盘输入有关。我们都知道弹出的键盘也是一个UIWindow对象，不过有别于我们经常使用的keyWindow，那么这些window对象谁来管理呢？可能这是一个思路。</p>

<p>最近时间有限，要继续练习项目了，这个问题就暂时解决到这里，就算是一次对OC运行时和Method Swizzing的小实践吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift面向协议编程初探 | WWDC 2015学习笔记]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/07/21/protocol-oriented-programming-first/"/>
    <updated>2015-07-21T14:05:26+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/07/21/protocol-oriented-programming-first</id>
    <content type="html"><![CDATA[<p>最近有时间，挑了几个今年WWDC中比较感兴趣的Session视频来学习，今天就抽时间整理一下关于<code>Swift 2.0</code>中一个比较新的概念<code>面向协议编程</code>。</p>

<p>相关的Session视频链接如下：</p>

<ul>
<li><a href="https://developer.apple.com/videos/wwdc/2015/?id=408">Session 408: Protocol-Oriented Programming in Swift</a></li>
<li><a href="https://developer.apple.com/videos/wwdc/2015/?id=414">Session 414: Building Better Apps with Value Types in Swift</a></li>
</ul>


<h2>写在前面</h2>

<h4>面向协议编程是什么？</h4>

<p>你可能听过类似的概念：<strong>面向对象编程</strong>、<strong>函数式编程</strong>、<strong>泛型编程</strong>，再加上苹果今年新提出的<strong>面向协议编程</strong>，这些统统可以理解为是一种编程范式。所谓编程范式，是隐藏在编程语言背后的思想，代表着语言的作者想要用怎样的<strong>方式</strong>去解决怎样的<strong>问题</strong>。不同的编程范式反应在现实世界中，就是不同的编程语言适用于不同的领域和环境，比如在面向对象编程思想中，开发者用对象来描述万事万物并试图用对象来解决所有可能的问题。编程范式都有其各自的偏好和使用限制，所以越来越多的现代编程语言开始支持<strong>多范式</strong>，使语言自身更强壮也更具适用性。</p>

<!--more-->


<p>更多编程范式和相关概念请参看：<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B">维基百科：编程范式</a></p>

<p>对Swift语言所采用的编程范式感兴趣的朋友可以参看这篇文章：<a href="http://lincode.github.io/Swift-Paradigm/">多范式编程语言－以 Swift 为例</a></p>

<h4>面向协议编程长什么样子？</h4>

<p>在详细解释面向协议编程之前，我们先简单地概括一下面向协议编程长什么样子？它与我们熟悉的面向对象编程有什么不一样？</p>

<p>简单来说，面向协议编程是在面向对象编程基础上演变而来，将程序设计过程中遇到的数据类型的抽取（抽象）由使用<strong>基类</strong>进行抽取改为使用<strong>协议</strong>（Java语言中的接口）进行抽取。更简单点举个栗子来说，一个猫类、一个狗类，我们很容易想到抽取一个描述动物的基类，也会有人想到抽取一个动物通用的协议，那后者就可以被叫做面向协议编程了。什么？就是这样而已？苹果官方那么正式的称Swift是一门支持面向协议编程的语言，难道就是这么简单的内容？当然不会，有过面向对象编程经验的人都会清楚，协议的使用限制很多，并不能适用于大多数情况下数据类型的抽象。而在Swift语言中，协议被赋予了更多的功能和更广阔的使用空间，在Swift 2.0中，更为协议增加了扩展功能，使其能够胜任绝大多数情况下数据类型的抽象，所以苹果开始声称Swift是一门支持面向协议编程的语言。</p>

<p>面向协议编程对比面向对象编程的好处在哪里？它会对我们程序的设计造成哪些影响？我们会在下文中继续分析。</p>

<h2>写在中间</h2>

<h4>离开面向对象我们失去了什么？</h4>

<p>首先，让我们来看看面向对象编程为我们带来的好处。绝大多数熟悉一种或几种面向对象编程语言的开发者都能随口说出几条面向对象编程的优点，比如数据的封装、数据访问的控制、数据类型的抽象、代码的可读性和可扩展性等。这意味着离开了面向对象编程我们也就失去了如此多的好处。</p>

<blockquote><p>哦，天呐！不要这样好嘛？</p></blockquote>

<p>回头仔细想想，这些好处只有面向对象编程才有嘛？苹果给了我们另一种答案：<em>It&rsquo;s Type, not Classes</em>，是抽象的<strong>类型</strong>带给我们如此多的好处，并不是面向对象中的<strong>类</strong>，类只是抽象类型的一种方式。比如在Swift语言中，使用结构体和枚举也同样能够实现对类型的抽象、数据的封装和访问控制等，这些好处又都回来了。</p>

<p>那么有没有什么是类能带给我们，而结构体和枚举办不到的呢？当然有，不然我们真的可以离开面向对象了。面向对象编程还有两个非常重要的特性我们还没有提到：继承和多态。继承和多态为我们带来了丰富多彩的世界，想想我们Cocoa Touch中的框架，这才是我们所熟悉的面向对象编程，它使我们能够轻易地解决所面对的问题，并使我们的代码具有高度的可定制和可重用性。</p>

<blockquote><p>我们的世界终于好像正常了。</p></blockquote>

<h4>拥有面向对象我们又得到了什么？</h4>

<p>那么，面向对象编程在带给我们这么多好处的同时，是否还附带了其他一些特性呢？比如说：要花费的代价。</p>

<p>我们先来看出现的第一个问题，多数面向对象语言中的对象都是使用引用类型，在对象传递过程中只是将引用复制一份并指向原有的对象，这样就会出现问题。比如下面代码所示的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Book</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">pages</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">pages</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="n">pages</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">book</span><span class="p">:</span> <span class="n">Book</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">book</span><span class="p">:</span> <span class="n">Book</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">book</span> <span class="o">=</span> <span class="n">book</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="err">围城</span> <span class="o">=</span> <span class="n">Book</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;围城&quot;</span><span class="p">,</span> <span class="nl">pages</span><span class="p">:</span> <span class="mi">888</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="err">小明</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;小明&quot;</span><span class="p">,</span> <span class="nl">book</span><span class="p">:</span> <span class="err">围城</span><span class="p">)</span> <span class="c1">// 小明有一本全新的《围城》</span>
</span><span class='line'><span class="n">let</span> <span class="err">小刚</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;小刚&quot;</span><span class="p">,</span> <span class="nl">book</span><span class="p">:</span> <span class="err">围城</span><span class="p">)</span> <span class="c1">// 小刚也有一本全新的《围城》</span>
</span><span class='line'><span class="err">小明</span><span class="p">.</span><span class="n">book</span><span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="mi">88</span> <span class="c1">// 小明淘气把书弄坏了，只剩88页了</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="err">小刚</span><span class="p">.</span><span class="n">book</span><span class="p">.</span><span class="n">pages</span><span class="p">)</span> <span class="c1">// 输出结果：88  WTF! Where is my new book?</span>
</span></code></pre></td></tr></table></div></figure>


<p>故事的结尾是：小刚因为弄坏书被妈妈打了~  不对啊，小明哪去了？我也不知道~</p>

<p>相信大多数面向对象编程语言的开发者都明白这是引用传递的原因，通常我们的解决办法也很简单，每次赋值的时候都先拷贝一份再进行赋值。当我们尝试在上述代码中加入copy方法时，却发现在Swift中对象默认并没有copy方法，这是因为Swift更推荐使用值类型变量而不是引用类型的变量。如果真的需要调用copy方法，你可以将Book类继承自NSObject，但这样的做法真的一点都不优雅，也不够<code>Swiftpyer</code>。实际上我们的问题也可以采用如下的解决办法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Book</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">pages</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">pages</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="n">pages</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">book</span><span class="p">:</span> <span class="n">Book</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">book</span><span class="p">:</span> <span class="n">Book</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">book</span> <span class="o">=</span> <span class="n">Book</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">book</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="nl">pages</span><span class="p">:</span> <span class="n">book</span><span class="p">.</span><span class="n">pages</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="err">围城</span> <span class="o">=</span> <span class="n">Book</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;围城&quot;</span><span class="p">,</span> <span class="nl">pages</span><span class="p">:</span> <span class="mi">888</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="err">小明</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;小明&quot;</span><span class="p">,</span> <span class="nl">book</span><span class="p">:</span> <span class="err">围城</span><span class="p">)</span> <span class="c1">// 小明有一本全新的《围城》</span>
</span><span class='line'><span class="n">let</span> <span class="err">小刚</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;小刚&quot;</span><span class="p">,</span> <span class="nl">book</span><span class="p">:</span> <span class="err">围城</span><span class="p">)</span> <span class="c1">// 小刚也有一本全新的《围城》</span>
</span><span class='line'><span class="err">小明</span><span class="p">.</span><span class="n">book</span><span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="mi">88</span> <span class="c1">// 小明淘气把书弄坏了，只剩88页了</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="err">小刚</span><span class="p">.</span><span class="n">book</span><span class="p">.</span><span class="n">pages</span><span class="p">)</span> <span class="c1">// 输出结果：888</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们在Person的构造方法中，为book属性新创建了一本书，从而保证小明和小刚各自拥有自己的书。这个解决办法可能并不适用于所有引用类型传递的情况，那么在Swift中，最好的解决办法是什么呢？其实答案很简单，使用值类型而非引用类型。Swift中许多常见的数据类型、字符串、集合类型，以及结构体和枚举都是值类型而非引用类型，值类型的变量在赋值时会自动进行一次低消耗的值拷贝，对比对象的copy要更加高效而且不存在线程安全问题。所以我们上面这个故事的最好结局是：将Book修改为结构体类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Book</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">pages</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">pages</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="n">pages</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">book</span><span class="p">:</span> <span class="n">Book</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">book</span><span class="p">:</span> <span class="n">Book</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">book</span> <span class="o">=</span> <span class="n">book</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="err">围城</span> <span class="o">=</span> <span class="n">Book</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;围城&quot;</span><span class="p">,</span> <span class="nl">pages</span><span class="p">:</span> <span class="mi">888</span><span class="p">)</span>
</span><span class='line'><span class="n">var</span> <span class="err">小明</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;小明&quot;</span><span class="p">,</span> <span class="nl">book</span><span class="p">:</span> <span class="err">围城</span><span class="p">)</span> <span class="c1">// 小明有一本全新的《围城》</span>
</span><span class='line'><span class="n">let</span> <span class="err">小刚</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;小刚&quot;</span><span class="p">,</span> <span class="nl">book</span><span class="p">:</span> <span class="err">围城</span><span class="p">)</span> <span class="c1">// 小刚也有一本全新的《围城》</span>
</span><span class='line'><span class="err">小明</span><span class="p">.</span><span class="n">book</span><span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="mi">88</span> <span class="c1">// 小明淘气把书弄坏了，只剩88页了</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="err">小刚</span><span class="p">.</span><span class="n">book</span><span class="p">.</span><span class="n">pages</span><span class="p">)</span> <span class="c1">// 输出结果：888</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>小刚终于得救了~</p></blockquote>

<p>想了解更多值类型的使用及其相关信息可以参看：<a href="https://developer.apple.com/videos/wwdc/2015/?id=414">Session 414: Building Better Apps with Value Types in Swift</a></p>

<p>我们刚刚使用一个例子解释了面向对象编程中使用引用类型可能出现的问题，接下来我们谈论另一个非常重要的话题：<strong>继承的代价</strong>。这并不是一个新颖的话题，自面向对象编程诞生之日起就饱受争议，我们经常要忍受着愈加繁杂和庞大的继承体系来获得代码的可重用性，而且随着继承层次的增加，代码的复杂性会加速增长，随之而来的bug也会越来越难以发现。这时我们可能需要依靠设计模式来找回我们的思路，然而大多数设计模式只能帮助你理顺你的代码结构，却在同时更加加深了你的代码的复杂度。</p>

<p>继承带给我们的另一个好处就是多态，多态极大地增强了我们代码的可扩展性。然而就像“<em>能量守恒定律</em>”一样，多态也带来了一定的负面影响，那就是类型信息的缺失。形象一点讲，就是我们常常会写出这样的代码：<code>subClassObject as! SubClass</code>，向下类型转换。</p>

<h4>那么问题来了：什么是更好的抽象类型？</h4>

<p>苹果官方对这个问题的回答如下：</p>

<ul>
<li>更多地支持值类型，同时也支持引用类型</li>
<li>更多地支持静态类型关联（编译期），同时也支持动态派发（运行时）</li>
<li>结构不庞大不复杂</li>
<li>模型可扩展</li>
<li>不给模型强制添加数据</li>
<li>不给模型增加初始化任务的负担</li>
<li>清楚哪些方法该实现哪些方法不需实现</li>
</ul>


<p>其实答案就是Swift中的面向协议编程，苹果只是在自卖自夸而已。</p>

<h2>面向协议编程</h2>

<p>接下来我们就正式进入Swift的面向协议编程的世界。首先我们来对比如下两段示例代码，代码的功能是定义一个更具扩展性的二分查找法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Ordered</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">precedes</span><span class="p">(</span><span class="nl">other</span><span class="p">:</span> <span class="n">Ordered</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span> <span class="n">fatalError</span><span class="p">(</span><span class="s">&quot;implement me!&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="nl">Number</span><span class="p">:</span> <span class="n">Ordered</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">value</span><span class="p">:</span> <span class="n">Double</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">override</span> <span class="n">func</span> <span class="n">precedes</span><span class="p">(</span><span class="nl">other</span><span class="p">:</span> <span class="n">Ordered</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">other</span> <span class="n">as</span><span class="o">!</span> <span class="n">Number</span><span class="p">).</span><span class="n">value</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="n">binarySearch</span><span class="p">(</span><span class="nl">sortedKeys</span><span class="p">:</span> <span class="p">[</span><span class="n">Ordered</span><span class="p">],</span> <span class="n">forKey</span> <span class="nl">k</span><span class="p">:</span> <span class="n">Ordered</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">sortedKeys</span><span class="p">.</span><span class="n">count</span>
</span><span class='line'>    <span class="k">while</span> <span class="n">hi</span> <span class="o">&gt;</span> <span class="n">lo</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="p">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">sortedKeys</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">precedes</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">lo</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">protocol</span> <span class="n">Ordered</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">precedes</span><span class="p">(</span><span class="nl">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="nl">Number</span><span class="p">:</span> <span class="n">Ordered</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">value</span><span class="p">:</span> <span class="n">Double</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">precedes</span><span class="p">(</span><span class="nl">other</span><span class="p">:</span> <span class="n">Number</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="n">binarySearch</span><span class="o">&lt;</span><span class="nl">T</span><span class="p">:</span> <span class="n">Ordered</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">sortedKeys</span><span class="p">:</span> <span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">forKey</span> <span class="nl">k</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">sortedKeys</span><span class="p">.</span><span class="n">count</span>
</span><span class='line'>    <span class="k">while</span> <span class="n">hi</span> <span class="o">&gt;</span> <span class="n">lo</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="p">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">sortedKeys</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">precedes</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">lo</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>应该不难看出两者之间的区别以及孰优孰劣，简单解释一下前者的缺点，反过来也就是后者的优点了。</p>

<ul>
<li>OC语言中没有抽象类这个概念，所有抽象类都是靠文档注释标明，这很蛋疼~</li>
<li>其他类型若想使用该二分查找法，必须继承自Ordered抽象类，在单继承体系中，该类型将无法再继承其他类型</li>
<li>方法参数接收的数组中，类型要求不严格，可以放入多种不同类型的Ordered子类对象</li>
<li>基于前一点原因，为保证严谨性，必须在方法实现内部增加类型判断，这更加蛋疼~~</li>
</ul>


<p>基于上面的例子，我们可以稍微感受到面向协议编程在扩展性上的优势了，这里再提几个注意点。</p>

<ul>
<li>Swift 2.0新特性之一，将<strong>Self</strong>用于约束泛型，功能类似于OC中的instancetype，示例：<code>extension Ordered where Self: Comparable</code></li>
<li>Swift 2.0另一个重要的新特性，协议可扩展，意味着你不仅可以扩展一个类型使其遵守Ordered协议，还可以直接扩展某个协议，详见如下两段代码示例。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 扩展类型</span>
</span><span class='line'><span class="n">extension</span> <span class="nl">Int</span><span class="p">:</span> <span class="n">Ordered</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">precedes</span><span class="p">(</span><span class="nl">other</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">self</span> <span class="o">&lt;</span> <span class="n">other</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">extension</span> <span class="nl">String</span><span class="p">:</span> <span class="n">Ordered</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">precedes</span><span class="p">(</span><span class="nl">other</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">self</span> <span class="o">&lt;</span> <span class="n">other</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">intIndex</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="nl">forKey</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// 输出结果2</span>
</span><span class='line'><span class="n">let</span> <span class="n">stringIndex</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="p">([</span><span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">,</span> <span class="s">&quot;5&quot;</span><span class="p">,</span> <span class="s">&quot;7&quot;</span><span class="p">],</span> <span class="nl">forKey</span><span class="p">:</span> <span class="s">&quot;5&quot;</span><span class="p">)</span> <span class="c1">// 输出结果2</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 扩展协议：方式一</span>
</span><span class='line'><span class="c1">//extension Comparable {</span>
</span><span class='line'><span class="c1">//    func precedes(other: Self) -&gt; Bool {</span>
</span><span class='line'><span class="c1">//        return self &lt; other</span>
</span><span class='line'><span class="c1">//    }</span>
</span><span class='line'><span class="c1">//}</span>
</span><span class='line'><span class="c1">// 扩展协议：方式二（Swift 2.0的推荐方式）</span>
</span><span class='line'><span class="n">extension</span> <span class="n">Ordered</span> <span class="n">where</span> <span class="nl">Self</span><span class="p">:</span> <span class="n">Comparable</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">precedes</span><span class="p">(</span><span class="nl">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">self</span> <span class="o">&lt;</span> <span class="n">other</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">extension</span> <span class="nl">Int</span><span class="p">:</span> <span class="n">Ordered</span> <span class="p">{}</span>
</span><span class='line'><span class="n">extension</span> <span class="nl">String</span><span class="p">:</span> <span class="n">Ordered</span> <span class="p">{}</span>
</span><span class='line'><span class="n">let</span> <span class="n">intIndex</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="nl">forKey</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// 输出结果2</span>
</span><span class='line'><span class="n">let</span> <span class="n">stringIndex</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="p">([</span><span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">,</span> <span class="s">&quot;5&quot;</span><span class="p">,</span> <span class="s">&quot;7&quot;</span><span class="p">],</span> <span class="nl">forKey</span><span class="p">:</span> <span class="s">&quot;5&quot;</span><span class="p">)</span> <span class="c1">// 输出结果2</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码我们可以看出，协议可扩展所带来的功能之一就是能够为协议中的方法提供默认实现。</p>

<p>更多协议可扩展所带来的功能可以参看RayWenderlich上的这篇文章：</p>

<ul>
<li><a href="http://www.raywenderlich.com/109156/introducing-protocol-oriented-programming-in-swift-2">英文版：Introducing Protocol-Oriented Programming in Swift 2</a></li>
<li><a href="http://www.swiftyper.com/Swift/introducing-protocol-oriented-programming-in-swift-2.html">中文版：Swift 2.0之初识面向协议编程</a></li>
</ul>


<p>关于面向协议编程的完整示例程序可以参看苹果官方的示例代码：</p>

<ul>
<li><a href="https://developer.apple.com/sample-code/wwdc/2015/downloads/Crustacean.zip">完整示例程序：Crustacean</a></li>
</ul>


<h2>写在最后</h2>

<h4>个人总结</h4>

<p>面向对象编程和面向协议编程最明显的区别在于程序设计过程中对数据类型的抽取（抽象）上，面向对象编程使用类和继承的手段，数据类型是引用类型；而面向协议编程使用的是遵守协议的手段，数据类型是值类型（Swift中的结构体或枚举）。</p>

<p>面向协议编程是在面向对象编程基础上发展而来的，而并不是完全背离面向对象编程的思想。</p>

<p>面向对象编程是伟大的编程思想，也是当今主流的编程思想，它的问题在于被过多的使用在其实并不需要使用它的情况下。</p>

<p>Swift是一门支持多编程范式的语言，既支持面向对象编程，也支持面向协议编程，同时还支持函数式编程。在项目开发过程中，控制器和视图部分由于使用系统框架，应更多采用面向对象编程的方式；而模型或业务逻辑等自定义类型部分，则应优先考虑面向协议编程。</p>

<p>PS. 这篇文章的写作过程持续了很长时间，中间几乎夭折，最后还是尽量将它写完整（其实后半部分写的很水）。面向协议编程是一个比较新的概念，目前只是隐约可以看出它的一些长处（在一些使用面向对象编程并不太适合的地方），不过苹果已经在自身框架中开始使用了，并确实改善了系统一些类型和方法的使用。</p>

<h4>参考资料</h4>

<ul>
<li><a href="http://www.infoq.com/news/2015/06/protocol-oriented-swift">Protocol-Oriented Programming in Swift</a></li>
<li><a href="http://owensd.io/2015/06/17/protocol-oriented-programming.html">Protocol Oriented Programming</a></li>
<li><a href="http://blog.metaobject.com/2015/06/protocol-oriented-programming-is-object.html">Protocol-Oriented Programming is Object-Oriented Programming</a></li>
<li><a href="https://medium.com/ios-os-x-development/heterogeneous-vs-homogeneous-generics-630971626b7d">Heterogeneous vs Homogeneous Containers in Swift</a></li>
<li><a href="http://krakendev.io/blog/subclassing-can-suck-and-heres-why">If You&rsquo;re Subclassing, You&rsquo;re Doing It Wrong</a></li>
<li><a href="http://lincode.github.io/Swift-Paradigm/">推荐必读文章：多范式编程语言－以 Swift 为例</a></li>
</ul>


<p>最后，让我们记住这张图：（<em>Quiz: Who is Crusty at Apple?</em>）</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/protocol-01.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C 读书笔记(二) | 理解OC运行时]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/07/09/effective-oc-note-second/"/>
    <updated>2015-07-09T16:31:43+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/07/09/effective-oc-note-second</id>
    <content type="html"><![CDATA[<h2>Class 类型对象</h2>

<p>OC本身是一种强类型语言，但其运行时功能让它又有了动态语言的特点。OC中对象的类型和对象所执行的方法都是在运行时阶段进行查找并确认的，这种机制被称为动态绑定。想要弄清楚运行时如何能够实现动态绑定机制，首先要了解OC中对象的本质。</p>

<p>OC是C语言的超集，所以OC中面向对象的功能在底层也是使用C语言来实现。我们在OC中使用的对象，通常指的是储存该对象内存地址的一个指针变量（Java中称为引用），因此我们在OC中声明对象时通常使用类型名称加一个<code>*</code>号，稍微了解C语言的人都知道<code>*</code>号代表该变量是一个指针变量。OC中还有一个特殊的类型<code>id</code>，它可以表示通用类型的OC对象，因为它本身就被定义为一种特殊的指针变量，所以不需要在id后面再加一个<code>*</code>号。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">someString</span> <span class="o">=</span> <span class="s">@&quot;Some String&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kt">id</span> <span class="n">otherString</span> <span class="o">=</span> <span class="s">@&quot;Other String&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">someString</span> <span class="n">count</span><span class="p">];</span> <span class="c1">// 编译期报错</span>
</span><span class='line'><span class="p">[</span><span class="n">otherString</span> <span class="n">count</span><span class="p">];</span> <span class="c1">// 运行时报错</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用上述两种方式声明对象，在语法意义上其实完全相同，因为对象的具体类型只在运行时才会被确认。唯一的区别在于，如果声明时使用了具体类型信息，编译器会在编译期间查找对象所能执行的方法，找不到就会报错；而<em>id</em>代表通用类型的对象，编译器默认它能够执行任何已存在的方法。</p>

<!--more-->


<p>我们可以在苹果官方的运行时库的头文件中查看<em>id</em>类型的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">Class</span> <span class="n">isa</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_object</span> <span class="o">*</span><span class="kt">id</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出<em>id</em>本质是一个C语言结构体，该结构体只有一个Class类型的成员<code>isa</code>（取意is a，是一个），代表着对象所属的具体类型。其实在NSObject类的头文件中，同样声明有一个这样的实例变量<em>isa</em>。因此，可以说OC中任何对象，都会默认带有一个实例变量<em>isa</em>用来储存对象的具体类型信息。</p>

<p>Class的定义也可以在运行时库的头文件中查看：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">objc_class</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">Class</span> <span class="n">isa</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">Class</span> <span class="n">super_class</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">version</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">info</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">instance_size</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">objc_ivar_list</span> <span class="o">*</span><span class="n">ivars</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">objc_method_list</span> <span class="o">**</span><span class="n">methodLists</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">objc_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">objc_protocol_list</span> <span class="o">*</span><span class="n">protocols</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_class</span> <span class="o">*</span><span class="kt">Class</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>此结构体可以储存类的诸多信息，例如类型名、父类类型、实例变量列表、方法列表等，这些信息被称作类的<code>元数据（metadata）</code>。该结构体也有一个Class类型的成员<em>isa</em>，说明Class本身也是一个OC对象（被称为类对象或类型对象），而它的对象类型（<em>isa</em>所指向的类型）被称为<code>元类（metaclass）</code>，元类中储存的是类对象的元数据，比如类方法就储存在这里。每个类可以有无数个对象，但仅有一个类对象，也仅有一个与之对应的元类。</p>

<p>对象、类对象和元类的关系如下图所示：</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/eoc01.png" alt="" /></p>

<p>由于类对象和<em>isa</em>指针的存在，OC中的所有对象都可以在运行时查找自己的真实类型，并确定自己所能执行的方法。当真正给对象发送一条消息（或称为调用方法）时，运行时机制会对该消息进行一系列复杂的处理，接下来我们就继续讨论运行时的消息处理。</p>

<h2>Message Dispatch 消息派发</h2>

<p>调用对象的某个方法（或称为给对象发送某个消息）是面向对象编程中最常使用的功能。在OC中，由于动态绑定机制使得程序直到运行时才能清楚那个方法需要被执行，甚至通过使用底层的运行时函数，就可以更改调用的方法或改变方法内部的功能实现，这些特性使得OC成为一门真正的动态语言。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">returnValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">someObject</span> <span class="nl">messageName</span><span class="p">:</span><span class="n">param</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>OC的消息处理，在底层也是使用C语言函数来实现，与消息处理功能相对应的函数叫做<code>objc_msgSend</code>，该函数在头文件中的声明如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">objc_msgSend</span><span class="p">(</span><span class="kt">id</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">op</span><span class="p">,</span> <span class="p">...)</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出<em>objc_msgSend</em>是一个可变参数函数，其中第一个参数代表消息的接收者，第二个参数代表消息的选择器，后续参数表示消息发送时附带的参数。编译器在编译期间就会将发送消息的代码转换为<em>objc_msgSend</em>函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">returnValue</span> <span class="o">=</span> <span class="n">objc_msgSend</span><span class="p">(</span><span class="n">someObject</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">messageName</span><span class="p">:),</span> <span class="n">param</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在运行时阶段，<em>objc_msgSend</em>函数内部会根据消息的接收者和选择器来选择调用适当的方法。为完成此操作，<em>objc_msgSend</em>函数首先会根据消息接收者对象的isa指针找到它的真实类型，然后在该类对象的方法列表中查找是否有与当前选择器相对应的方法，如果有则跳转到该方法执行；如果没有找到，则会按照类的继承体系向上继续查找，一旦找到就跳转过去执行目标方法。当最终都没有找到与当前选择器相对应的方法时，运行时机制则会开启消息转发流程，我们接下来就继续讨论运行时的消息转发。</p>

<h2>Message Forward 消息转发</h2>

<p>消息转发流程比较复杂，主要分三个步骤，首先我们来看一张消息转发完整的流程图。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/eoc02.png" alt="" /></p>

<h4>第一步</h4>

<p>当消息派发流程最终在对象的类和父类中都没有找到对应选择器的方法时，就会开启消息转发流程。首先，第一步会先调用消息接收者所在类的<code>resolveInstanceMethod:</code>方法，该方法返回一个BOOL值，表示是否动态添加一个方法来响应当前消息选择器。如果发送的消息是一个类方法，则会调用另一个类似的方法<code>resolveClassMethod:</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">resolveInstanceMethod:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">sel</span><span class="p">;</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">resolveClassMethod:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">sel</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上两个方法均声明在NSObject类中，如果消息接收者所在类重写了<code>resolveInstanceMethod:</code>方法并返回<em>YES</em>，也就意味着想要动态添加一个方法来响应当前的消息选择器，可以在重写的方法内使用<code>class_addMethod</code>函数来为当前类添加方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">BOOL</span> <span class="n">class_addMethod</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">name</span><span class="p">,</span> <span class="kt">IMP</span> <span class="n">imp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">types</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>该函数第一个参数代表为哪个类添加方法，第二个参数是方法所对应的选择器，第三个参数是C语言的函数指针，用来指向待添加的方法，最后一个参数表示待添加方法的类型编码（详情可查看苹果官方文档：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Objective-C Runtime Programming Guide</a>）。</p>

<h4>第二步</h4>

<p>如果上一步过程中，并没有新方法能响应消息选择器，则会进入消息转发流程的第二步。在第二步中系统会调用当前消息接收者所在类的<code>forwardingTargetForSelector:</code>方法，用以询问能否将该条消息发送给其他接收者来处理，方法的返回值就代表这个新的接收者，如果不允许将消息转发给其他接收者则返回<em>nil</em>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">forwardingTargetForSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>利用这个方法，我们可以使用组合的方式模拟出多重继承的特性。比如可以在一个类中拥有一系列其他类型的属性，然后重写<code>forwardingTargetForSelector:</code>方法，根据这些属性所能响应的消息选择器返回对应的属性对象，这样在外界看起来，该类的对象就好像是能够处理多种不同类型的方法了。</p>

<h4>第三步</h4>

<p>如果<code>forwardingTargetForSelector:</code>方法的返回值为<em>nil</em>，那么消息转发机制还要继续进行最后一步。在这一步中，系统会将尚未处理的消息包装成一个<code>NSInvocation</code>对象，其内部包含与该消息相关的所有信息，比如消息的选择器、目标接收者、参数等。之后系统会调用消息接收者所在类的<code>forwardInvocation:</code>方法，并将生成的<code>NSInvocation</code>对象作为参数传入。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">forwardInvocation:</span><span class="p">(</span><span class="bp">NSInvocation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anInvocation</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>forwardInvocation:</code>方法同样声明在NSObject类中，我们可以重写该方法的实现。比如将<code>NSInvocation</code>对象的<code>target</code>属性设置为其他接收者，此操作可以实现与上一步操作同样的效果，但明显在效率上没有第二步的操作高，所以很少有人在这一步中仅仅只是改变消息的接收者。<code>NSInvocation</code>类中还提供了许多属性和方法用于修改其对应方法的信息，比如可以修改方法的参数和返回值，或者直接更改消息选择器转而调用其他方法。</p>

<p>如果消息接收者在这一步中仍然无法响应消息选择器，那么系统会自动调用<code>doesNotRecognizeSelector:</code>方法，该方法默认实现为抛出异常，也就是我们在开发中经常见到的<em>unrecognized selector sent to instance</em>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">-</span><span class="p">[</span><span class="n">ViewController</span> <span class="n">count</span><span class="p">]</span><span class="o">:</span> <span class="n">unrecognized</span> <span class="n">selector</span> <span class="n">sent</span> <span class="n">to</span> <span class="n">instance</span>
</span></code></pre></td></tr></table></div></figure>


<h4>消息转发示例</h4>

<p>现在再回头看我们之前消息转发完整的流程图，应该能够更清晰地了解系统执行每一步操作的目的和作用了。接下来我们用一个示例来演示如何利用消息转发机制来自定义一个字典类，该字典类的对象可以直接使用属性方式来存取内容。完整的示例代码如下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// WXGAutoDictionary.h</span>
</span><span class='line'><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">WXGAutoDictionary</span> : <span class="bp">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 可供存储的属性，可以为任意OC对象</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// WXGAutoDictionary.m</span>
</span><span class='line'><span class="cp">#import &quot;WXGAutoDictionary.h&quot;</span>
</span><span class='line'><span class="cp">#import &lt;objc/runtime.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">WXGAutoDictionary</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSMutableDictionary</span> <span class="o">*</span><span class="n">backStore</span><span class="p">;</span> <span class="c1">// 后台存储用字典</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">WXGAutoDictionary</span>
</span><span class='line'>
</span><span class='line'><span class="k">@dynamic</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">// 禁止编译器自动生成getter和setter方法</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_backStore</span> <span class="o">=</span> <span class="l">@{}</span><span class="p">.</span><span class="n">mutableCopy</span><span class="p">;</span> <span class="c1">// 初始化字典</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 重写此方法，允许动态添加方法来响应指定的消息选择器</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">resolveInstanceMethod:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">sel</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">selString</span> <span class="o">=</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">sel</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 类型编码：v-&gt;void  @-&gt;OC对象  :-&gt;SEL选择器</span>
</span><span class='line'>    <span class="c1">// 响应setter方法的选择器</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([</span><span class="n">selString</span> <span class="nl">hasPrefix</span><span class="p">:</span><span class="s">@&quot;set&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">class_addMethod</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="p">(</span><span class="kt">IMP</span><span class="p">)</span><span class="n">autoDictionarySetter</span><span class="p">,</span> <span class="s">&quot;v@:@&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 响应getter方法的选择器</span>
</span><span class='line'>        <span class="n">class_addMethod</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="p">(</span><span class="kt">IMP</span><span class="p">)</span><span class="n">autoDictionaryGetter</span><span class="p">,</span> <span class="s">&quot;@@:&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 处理setter方法的函数</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">autoDictionarySetter</span><span class="p">(</span><span class="kt">id</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">sel</span><span class="p">,</span> <span class="kt">id</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">WXGAutoDictionary</span> <span class="o">*</span><span class="n">autoDict</span> <span class="o">=</span> <span class="p">(</span><span class="n">WXGAutoDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSMutableDictionary</span> <span class="o">*</span><span class="n">backStore</span> <span class="o">=</span> <span class="n">autoDict</span><span class="p">.</span><span class="n">backStore</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">selString</span> <span class="o">=</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">sel</span><span class="p">);</span>
</span><span class='line'>    <span class="bp">NSMutableString</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">selString</span><span class="p">.</span><span class="n">mutableCopy</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">key</span> <span class="nl">deleteCharactersInRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">key</span> <span class="nl">deleteCharactersInRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">key</span> <span class="nl">replaceCharactersInRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="nl">withString</span><span class="p">:[[</span><span class="n">key</span> <span class="nl">substringToIndex</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="n">lowercaseString</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">backStore</span> <span class="nl">setObject</span><span class="p">:</span><span class="n">value</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">backStore</span> <span class="nl">removeObjectForKey</span><span class="p">:</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 处理getter方法的函数</span>
</span><span class='line'><span class="kt">id</span> <span class="nf">autoDictionaryGetter</span><span class="p">(</span><span class="kt">id</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">sel</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">WXGAutoDictionary</span> <span class="o">*</span><span class="n">autoDict</span> <span class="o">=</span> <span class="p">(</span><span class="n">WXGAutoDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSMutableDictionary</span> <span class="o">*</span><span class="n">backStore</span> <span class="o">=</span> <span class="n">autoDict</span><span class="p">.</span><span class="n">backStore</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">sel</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">backStore</span> <span class="nl">objectForKey</span><span class="p">:</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在外部使用该类非常简单，示例代码如下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//  main.m</span>
</span><span class='line'><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class='line'><span class="cp">#import &quot;WXGAutoDictionary.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">WXGAutoDictionary</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="p">[[</span><span class="n">WXGAutoDictionary</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="n">dict</span><span class="p">.</span><span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">.</span><span class="n">obj</span><span class="p">);</span> <span class="c1">// 控制台输出当前日期</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在程序开始运行后，<em>dict</em>对象所在的类中并没有响应setter和getter选择器的方法，消息派发阶段无法在类对象的方法列表中找到合适的方法，所以会进入消息转发流程。我们在<code>resolveInstanceMethod:</code>方法中返回<em>YES</em>，并为不同选择器指定了不同的方法去处理，从而实现通过属性的setter和getter方法对字典进行存取操作。当有另一个类型的属性需要使用同样的功能时，只需在<code>WXGAutoDictionary</code>类中添加属性，并将属性声明为<code>@dynamic</code>即可，属性的存取操作会由运行时系统动态指定方法来完成。</p>

<h2>Method Swizzing 方法调配</h2>

<p>我们已经了解了OC中对象的类型和消息处理机制，这些有助于我们进一步了解OC运行时的其他功能和特性。接下来就介绍其中一种叫做<code>Method Swizzing（方法调配）</code>的技术，该技术经常被称为iOS开发中的黑魔法。</p>

<p>在介绍方法调配技术之前，我们首先来了解一下OC中方法和消息选择器之间的关系，因为我们经常会将他们混为一谈。在运行时头文件中，我们可以找到方法的底层结构定义。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">objc_method</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">SEL</span> <span class="n">method_name</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">method_types</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">IMP</span> <span class="n">method_imp</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，每一个方法内部都包含三个成员，第一个是选择器代表方法的名字，第二个是方法的类型，其值是一个C语言字符串，可以参考前文讲过类型编码，最后一个是C语言中的函数指针，用以指向方法具体执行的函数。我们可以把方法的内部结构理解为每一个<em>SEL</em>选择器（可以当做是方法名）对应一个具体的<em>IMP</em>函数（可以当做是方法的实现），这也是<em>SEL</em>被称为选择器的原因。这样我们就可以更加清楚地理解消息派发时，系统是如何根据消息选择器来查找对应的方法并跳转到方法的具体实现的了。</p>

<p>首先，当对象接收到某个消息时，编译器首先将代码转换为<em>objc_msgSend</em>函数，并将消息的接收者和选择器当做函数的参数传入，接下来系统会根据接收者的<em>isa</em>指针找到它所对应的类，在类的元数据信息中找到该类所拥有的方法列表，然后遍历方法列表，将每一个方法内部的<em>SEL</em>选择器同传入的消息选择器进行匹配，当找到相同的选择器后，就根据方法内部的<em>IMP</em>函数指针跳转到方法的具体实现。当然，为了提高方法多次执行的效率，系统会将遍历查询的结果缓存起来，储存在类的元数据信息中，此处就不再继续深入讨论。</p>

<p>了解清楚选择器和方法实现之间的一对一关系后，我们接下来开始介绍方法调配技术，它其实就是利用运行时提供的函数来动态修改选择器和方法实现之间的对应关系的一种技术。利用这种技术，我们可以在运行时为某个类添加选择器或更改选择器所对应的方法实现，甚至可以更换两个已有选择器所对应的方法实现，从而实现一种极其诡异的效果。下面就写一段示例程序，通过方法调配技术来更换NSString类的大小写转换方法的实现（仅供娱乐使用）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//  main.m</span>
</span><span class='line'><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class='line'><span class="cp">#import &lt;objc/runtime.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Method</span> <span class="n">lowercase</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="bp">NSString</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">lowercaseString</span><span class="p">));</span>
</span><span class='line'>        <span class="n">Method</span> <span class="n">uppercase</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="bp">NSString</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">uppercaseString</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">lowercase</span><span class="p">,</span> <span class="n">uppercase</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@ -- %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">@&quot;AbCd&quot;</span> <span class="n">lowercaseString</span><span class="p">],</span> <span class="p">[</span><span class="s">@&quot;AbCd&quot;</span> <span class="n">uppercaseString</span><span class="p">]);</span>
</span><span class='line'>        <span class="c1">// 输出结果：ABCD -- abcd</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到<code>lowercaseString</code>方法返回的是大写字母，而<code>uppercaseString</code>方法返回了小写字母。</p>

<p>方法调配技术的作用肯定不在于此，那么开发者通常如何使用这种技术呢？在总结方法调配技术的用处之前，我们先再来看一个示例程序。同样以NSString类为例，我们为其<code>lowercaseString</code>方法增加一些日志输出功能（不改变方法名，只是更改方法的实现）。你可能第一时间想到用继承来实现该需求，然而当项目中有多个类需要同样需求时，你需要每个类都去继承一下，然后还要保证别人都是去用你的子类而不是原本的父类，这样显然并不是一种很好的解决办法。此时我们就可以尝试使用方法调配技术，完整的示例代码如下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//  NSString+Logging.h</span>
</span><span class='line'><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="bp">NSString</span> <span class="nl">(Logging)</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">lowercaseStringWithLogging</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  NSString+Logging.m</span>
</span><span class='line'><span class="cp">#import &quot;NSString+Logging.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="bp">NSString</span> <span class="nl">(Logging)</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">lowercaseStringWithLogging</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">lowercaseString</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">lowercaseStringWithLogging</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@ -&gt; %@&quot;</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="n">lowercaseString</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">lowercaseString</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  main.m</span>
</span><span class='line'><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class='line'><span class="cp">#import &lt;objc/runtime.h&gt;</span>
</span><span class='line'><span class="cp">#import &quot;NSString+Logging.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Method</span> <span class="n">lowercase</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="bp">NSString</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">lowercaseString</span><span class="p">));</span>
</span><span class='line'>        <span class="n">Method</span> <span class="n">lowercaselogging</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="bp">NSString</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">lowercaseStringWithLogging</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">lowercase</span><span class="p">,</span> <span class="n">lowercaselogging</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="s">@&quot;AbCd&quot;</span> <span class="n">lowercaseString</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 输出结果：AbCd -&gt; abcd</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们为NSString类添加一个分类，在分类中添加一个带日志输出功能的方法，注意在该方法的实现中，我们调用了这句代码<code>[self lowercaseStringWithLogging]</code>，这看上去应该会使程序陷入死循环，但不要忘了，我们在<em>main</em>方法中利用方法调配技术来交换原有类的方法和分类方法的实现，所以这句代码实际上执行的是原本的类中的实现，并不会造成死循环。</p>

<p>通过上文的示例程序，我们可以为那些完全不知道具体实现的方法（也称为黑盒方法）增加日志输出功能，这常用于程序的调试。实际上，还有很多与此类似的需求，既要增加功能，又需要与原有方法联系很紧密，例如增加权限验证和缓存功能，这类需求常被人们称为<code>Aspect（切面）</code>，与之对应的编程概念叫做<code>Aspect Oriented Programming（面向切面编程）</code>。面向切面编程的概念有许多优点，它将那些琐碎的事物从主逻辑中分离出来，并将它们附加在与主逻辑相对应的横向切面中连带执行，是对面向对象编程的一种补充。在OC中，我们可以利用运行时特性和方法调配技术来实现这类面向切面编程的需求。</p>

<h2>写在最后</h2>

<p>本文主要是自己整理的读书笔记，并重新整理归纳，内容只是OC运行时的一部分，只为理顺OC运行时的基本概念，从而为理解其他运行时特性打下基础。比如OC中经常使用的KVC和KVO，在理解本文这些运行时基本概念后，应该更有助于理解它们的实现原理，感兴趣的可以参考以下文章：</p>

<ul>
<li><a href="http://tech.glowing.com/cn/implement-kvo/">如何自己动手实现 KVO</a></li>
<li><a href="http://www.jianshu.com/p/25a319aee33d">Objective-C特性：Runtime</a></li>
<li><a href="http://blog.csdn.net/wzzvictory/article/details/9674431">KVC/KVO原理详解及编程指南</a></li>
</ul>


<p>还有OC运行时中的<code>Associated Object（关联对象）</code>概念，可以参考以下文章：</p>

<ul>
<li><a href="http://www.jianshu.com/p/3cbab68fb856">给分类（Category）添加属性</a></li>
</ul>


<p>其他参考阅读：</p>

<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1">Objective-C Runtime Programming Guide</a></li>
<li><a href="http://book.douban.com/subject/25829244/">Effective Objective C 2.0</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自己模仿的一个侧拉菜单的小Demo]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/07/06/slidemenu-demo/"/>
    <updated>2015-07-06T08:23:03+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/07/06/slidemenu-demo</id>
    <content type="html"><![CDATA[<p>学iOS开发也有段时间了，模仿写了一个简单实现侧拉菜单的小demo，供初学者共同学习、练习使用。</p>

<p>项目地址：<a href="https://github.com/WXGBridgeQ/WXGSlideMenuDemo">WXGSlideMenuDemo</a></p>

<p>实现效果如下：</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/SlideMenu.gif" alt="" /></p>

<p>例子和做法参考了<em>RayWenderlich</em>上的<a href="http://www.raywenderlich.com/87268/3d-effect-taasky-swift">这篇文章</a>，推荐英文好的同学可以多去<a href="http://www.raywenderlich.com/">这里</a>自行学习。</p>

<p><strong>7月7日更新：</strong></p>

<ul>
<li>修复了一个小bug（手动侧滑显示菜单后没有更改菜单是否显示的状态，导致有时按钮需要点击两次才能显示菜单</li>
<li>之前的Demo是使用storyboard+自动布局实现的，这次重新写了一份使用纯代码+frame的方式实现该功能的Demo，更加用心，代码质量更好，关键知识点已加注释，希望能帮助到更多的初学者。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building Adaptive UI 搭建自适应界面 | AppCoda翻译系列]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/06/30/adaptive-layout-tutorial/"/>
    <updated>2015-06-30T15:52:14+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/06/30/adaptive-layout-tutorial</id>
    <content type="html"><![CDATA[<p>（本文翻译自AppCoda创建者Simon Ng出版的书籍《iOS开发中级教程》，详见：<a href="http://www.appcoda.com/intermediate-swift-programming-book/">Intermediate iOS Programming with Swift</a>）</p>

<p>起初，iPhone只有一种3.5英寸的屏幕，那时的软件界面很容易搭建，开发者只需要处理两种不同方向上的界面展示（水平和竖直方向）。之后，苹果发布了9.7英寸屏幕的iPad，这个时候的开发者必须为他们的应用创建两个不同的界面（比如创建两个storyboard或者xib文件），一个用来搭建iPhone版的界面，另一个用来搭建iPad版的。</p>

<p>好日子一去不复返！从2014年开始，苹果公司的iPhone和iPad产品线变化很大。随着iPhone 6和iPhone 6 Plus的发布，现在的应用需要适配多种不同屏幕尺寸的设备，主要有如下几种：</p>

<ul>
<li>iPhone 4/4s（3.5英寸）</li>
<li>iPhone 5/5c/5s（4英寸）</li>
<li>iPhone 6（4.7英寸）</li>
<li>iPhone 6 Plus（5.5英寸）</li>
<li>iPad / iPad 2 / iPad Air / iPad Air 2（9.7英寸）</li>
<li>iPad mini / iPad mini 2 / iPad mini 3（7.9英寸）</li>
</ul>


<!--more-->


<p>对开发者来说，创建一个能够适配多种屏幕尺寸和方向的通用型界面是一个非常大的挑战。那么，我们如何来创建一个像素不被拉伸、界面完美的应用呢？</p>

<p>在iOS 8中，苹果推出了一种新技术叫做<code>Adaptive User Interfaces (自适应界面)</code>，它能够支持不同尺寸、不同方向屏幕的适配，使用这种技术，我们的应用就可以适配以上多种iPhone和iPad设备了。</p>

<p>实现自适应界面，需要了解一个新概念——<code>Adaptive Layout (自适应布局)</code>。在Xcode 6中，开发者可以通过使用<em>a universal storyboard</em>来搭建能够适配所有设备的自适应界面。现在，你可以只使用一个storyboard文件来布局你所有的视图控件，包括iPhone和iPad版本。</p>

<p>为了实现自适应布局，苹果在iOS 8中推出了<code>Size Classes</code>技术，它是实现自适应布局中最重要的一步。<code>Size Classes</code>是对不同尺寸、不同方向的设备的一种抽象，将<code>Size Classes</code>和<code>Auto Layout (自动布局)</code>技术结合起来使用，就能够搭建出自适应界面。在iOS 8中，实现自适应布局需要如下几个步骤：</p>

<ol>
<li>先使用自动布局来搭建你的界面，自动布局已经能够处理大多数尺寸和方向的适配任务。</li>
<li>针对不同的<em>size classes</em>添加特定的布局约束。比如说，当设备横屏时增加两个标签之间的间距。</li>
</ol>


<p>在本文中，我将介绍如何使用各种自适应界面技术来创建一个通用型的应用，它可以适配各种不同尺寸和方向的设备。</p>

<h2>自适应界面示例</h2>

<p>本次示例工程不需要编写代码，我们主要使用storyboard来布局我们的视图组件，并学习如何使用自动布局和<em>Size Classes</em>技术来实现自适应界面。通过本文的学习，你将会构建一个具有单一视图控制器的应用，该应用可以适配任何不同尺寸和方向的设备。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui01.png" alt="" /></p>

<h2>创建Xcode工程</h2>

<p>首先，启动Xcode，创建一个<code>Single View Application</code>的项目，项目名称填入<code>AdaptiveUIDemo</code>，并确保<code>Devices</code>选项选择的是<code>Universal</code>。</p>

<p>一旦创建完项目，打开<code>Main.storyboard</code>文件，你会看见一个600×600尺寸的方形控制器视图，因为使用了<code>Size Classes</code>功能，控制器的视图表示的是一个通用的设备，而不是像以前那样表示的是一个具体的设备（例如4英寸的iPhone）。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui02.png" alt="" /></p>

<p>你可以使用自动布局对视图组件（比如标签）进行约束，同以前旧版本的Xcode或者关闭了<code>Size Classes</code>功能的项目一样。</p>

<p>接下来，下载图片资源并将其添加到项目的<code>images.xcassets</code>里面。链接地址点击<a href="https://www.dropbox.com/s/1rnlpib0dtttom8/adaptiveui-images.zip?dl=0">这里</a>。（译注：原文资源文件地址需要FQ访问，本人已转存到这里：<a href="http://7xk1wz.com1.z0.glb.clouddn.com/tshirt.jpg">图片1</a>、<a href="http://7xk1wz.com1.z0.glb.clouddn.com/tshirt@2x.jpg">图片2</a>、<a href="http://7xk1wz.com1.z0.glb.clouddn.com/tshirt@3x.jpg">图片3</a>）</p>

<p>接下来，回到storyboard文件，往控制器中拖入一个<code>UIImageView</code>，设置它的宽度为600、高度为390，在属性选项卡中，设置image为<code>tshirt</code>，Mode选择<code>Aspect Fill</code>。在本文接下来的内容中，我将把这个<code>UIImageView</code>叫做产品图片视图。</p>

<p>然后，再往控制器中拖入一个<code>UIView</code>，放在产品图片视图的下面，设置它的宽度为600、高度为210。这个<code>UIView</code>将作为一个容器，用来装我们的其他视图控件（比如标签），把一些相关联的组件包装在一个父视图内，将更有利于我们对其进行布局。在本文接下来的内容中，我将把这个<code>UIView</code>叫做产品简介视图。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui03.png" alt="" /></p>

<p>接下来，往产品简介视图中拖入一个<code>UILable</code>，将其文本内容设置为<em>PSD T-Shirt Mockup Template</em>，将字体设置为<em>Avenir Next</em>，字体大小设置为32，在尺寸选项卡中，将X改为22、Y改为15、宽度改为556、高度改为44。在本文接下来的内容中，我将把这个<code>UILabel</code>叫做标题标签。</p>

<p>再拖入一个<code>UILabel</code>放在标题标签的下面，将其文本内容设置为<em>This is a free psd T-shirt mockup provided by pixeden.com. The PSD comes with a plain simple tee-shirt mockup template. You can edit the t-shirt color and use the smart layer to apply your designs. The high-resolution makes it easy to frame specific details with close-ups.</em>，同样将字体设置为<em>Avenir Next</em>，字体大小设为18，<em>Lines</em>设为0。在尺寸选项卡中，将X改为22、Y改为58、宽度改为556、高度改为123。在本文接下来的内容中，我将把这个<code>UILabel</code>叫做产品描述标签。</p>

<p>要注意这两个标签是放在产品简介视图里面的，你可以打开大纲视图来确认它们的层级关系是否正确。如果你做的正确，你的界面应该和下图所示一样。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui04.png" alt="" /></p>

<p>如果你的界面跟上图在位置上不完全一致也没关系，因为接下来要对这些控件添加约束进行自动布局。</p>

<p>现在先让我们来看一下我们的界面在不同的设备上表现如何。在Xcode 6中，你可以不通过启动模拟器运行程序就能看到你的界面如何展示。最新版本的Xcode提供了一个预览功能，可以使开发者快速方便地查看界面在不同尺寸设备上的样子。</p>

<p>如下图所示操作，点击助手弹出菜单选择预览，然后按住<em>shift</em>和<em>option</em>键点击<code>Main.storyboard</code>。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui05.png" alt="" /></p>

<p>你可以选择在哪个区域显示预览窗口。双击<em>main</em>旁边的加号按钮，Xcode会自动打开助手编辑视图并将应用界面的预览显示出来。默认显示出的是4英寸iPhone上应用界面的样子，你可以点击左下角的加号按钮来添加不同尺寸的设备，从而来查看应用界面在不同屏幕尺寸上的显示。如果你添加了所有尺寸的设备，包括iPad设备，你的屏幕现在应该跟下图所示一样。你会发现，我们现在的界面不能很好的适应所有的设备，这是因为我们还没有使用自动布局来给控件添加约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui06.png" alt="" /></p>

<h2>添加自动布局约束</h2>

<p>现在我们来为视图组件添加布局约束。首先从我们的产品图片视图开始，有些开发者对自动布局感到恐惧，我的习惯是先用普通的语言将约束描述一遍，以我们的产品图片视图为例，我认为对它的约束应该是下面这个样子：</p>

<ul>
<li>在产品图片视图和主视图之间，它们的上边、左边和右边的间距应该为0。</li>
<li>产品图片视图大约占主视图的65%~70%左右</li>
<li>产品图片视图和它下边的产品简介视图之间的间距也应该为0。</li>
</ul>


<p>把这些描述转换成自动布局的约束，看上去应该如下所示：</p>

<ul>
<li>约束产品图片视图的上边、左边和右边的间距，值设为0。</li>
<li>给产品图片视图增加一个相对于主视图的高度约束，将相乘的系数设为0.65。</li>
<li>添加产品图片视图和产品简介视图之间的间距约束，值设为0。</li>
</ul>


<p>现在我们开始设置这些约束，选择产品图片视图，点击自动布局菜单中的<em>Pin</em>按钮，选中上边、左边、右边的约束并设置为0，注意要确保<code>Constrain to margin</code>没有被选中，然后点击下边的按钮添加三个约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui07.png" alt="" /></p>

<p>接下来，打开左侧的大纲视图，按住<em>Control</em>键从产品图片视图拖到主视图，在弹出的菜单中选择等高约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui08.png" alt="" /></p>

<p>添加完等高约束后，该约束就会出现在大纲视图上。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui09.png" alt="" /></p>

<p>选中该约束，点击右侧的尺寸选项卡，在这里你可以对该约束进行自定义的设置。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui10.png" alt="" /></p>

<p>在设置之前，先查看一下<code>first item</code>中是否是<em>tshirt.Height</em>、<code>second item</code>中是否是<em>SuperView.Height</em>，如果不是，可以点击下拉菜单然后选择<em>Reverse First and Second item</em>。</p>

<p>默认情况下，两个高度值之间的相乘系数是1，代表着产品图片视图占据了主视图的100%，我们希望产品图片视图只是占据主视图的65%，所以将相乘的系数改为0.65。</p>

<p>接下来，选择产品简介视图，点击<em>Pin</em>按钮，选中左边、右边和下边的约束，设置为0。同样要确保<code>Constrain to margin</code>选项没有被选中，然后点击下边按钮添加三个约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui11.png" alt="" /></p>

<p>接下来，我们要为产品图片视图和产品简介视图添加间距约束。在大纲视图中，按住<em>Control</em>键从产品图片视图拖到产品简介视图。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui12.png" alt="" /></p>

<p>在弹出的菜单中选择<em>竖向间距</em>约束，这样我们就添加了产品图片视图的底部和产品简介视图的顶部之间的间距约束。</p>

<p>现在再预览一下我们的界面，你会发现在不同尺寸的设备上它看上去稍微好一些了，但是我们还可以做很多事情来让它变得更好。</p>

<p>现在，我们来为产品简介视图中的两个标签设置约束。</p>

<p>先选择标题标签，就是看上去字体更大的那个，点击自动布局的<em>Pin</em>按钮，设置它上边约束15、左边约束22、右边约束22，记住确保<code>Constrain to margin</code>选项没有被选中，然后点击下边的按钮添加三个约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui13.png" alt="" /></p>

<p>接下来，选择产品描述标签，用同样的办法设置它的下边约束29、左边约束22、右边约束22。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui14.png" alt="" /></p>

<p>最后，给两个标签添加间距约束，按住<em>Control</em>键从标题标签拖到产品描述标签，同样，在弹出的菜单中选择<em>竖向间距</em>约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui15.png" alt="" /></p>

<p>当你添加完这个约束后，你会在storyboard上发现很多黄色和红色的线，这表示我们的布局现在存在问题，当约束不明确或有冲突时就会产生布局问题。</p>

<p>要解决布局问题，可以点击大纲视图中的红色箭头，这样会列出现在存在所有的布局问题。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui16.png" alt="" /></p>

<p>Xcode非常智能可以帮助我们很容易地解决布局问题，通过点击红色指示器按钮，就会弹出多种可能的解决办法，我们选择<em>Change Priority</em>来解决我们之前的布局问题。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui17.png" alt="" /></p>

<p>非常棒！我们已经完成了所有视图控件的自动布局，现在重新在预览视图中查看我们的界面在不同尺寸设备上的展示。</p>

<p>界面看上去比之前要好多了，产品图片已经能正确的显示。然而，我们的界面还有以下几处问题需要解决：</p>

<ul>
<li>产品描述标签在iPad上被竖向居中显示了</li>
<li>标题标签不能被完整地显示，尤其是在iPhone设备上</li>
<li>产品描述标签在iPhone上也只是部分显示</li>
</ul>


<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui18.png" alt="" /></p>

<p>我们先来解决第一条问题，很明显，问题应该出在我们为产品描述标签添加的约束上。你可以在尺寸选项卡里面查看已经添加的约束。选择产品描述标签，然后选择尺寸选项卡。</p>

<p>你会发现如下图所示的一系列约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui19.png" alt="" /></p>

<p>我们给产品描述标签添加了四个约束，很明显，我们的问题应该与上边和下边的间距约束有关。</p>

<p>在自动布局中，每一个约束都有一个优先级的概念，高优先级的约束会比低优先级的约束优先被执行。所有新建的约束其优先级都会被设为一个相同的值（值为1000），意味着所有约束都同等重要、都需要被执行。我们产品描述标签的上边和下边约束的优先级相同，但是看上去好像下边的约束更胜一筹，导致我们标题标签和产品描述标签中间出现了一个很大的间距。</p>

<p>要解决这个问题，应该把产品描述标签的下边间距约束的优先级降低。点击下边间距约束上的<em>Edit</em>按钮，将<em>priority</em>的值改为250。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui20.png" alt="" /></p>

<p>这样完成之后，我们的第一条界面问题就解决了。</p>

<h2>Size Classes</h2>

<p>不要忘了，我们之前提到过自适应界面技术需要两个步骤，到目前为止我们只是完成了界面的自动布局，自动布局能够满足大多数情况下的界面适配，接下来的第二步我们将使用<code>Size Classes</code>技术让我们的界面看上去更加完美。</p>

<p>一个<code>size class</code>代表了一种或多种屏幕尺寸的抽象，包括竖直方向（高度）和水平方向（宽度）的尺寸。在iOS 8中有两种类型的<code>size class</code>：<em>regular</em>(整齐的)和<em>compact</em>（紧凑的）。<em>regular</em>类型的<code>size class</code>表示一个比较大的屏幕空间，<em>compact</em>类型的<code>size class</code>则表示一个比较小的屏幕空间。</p>

<p>使用<code>size classes</code>来抽象地描述屏幕的尺寸，会有以下四种结果：<code>Regular width-Regular Height</code>、<code>Regular width-Compact Height</code>、<code>Compact width-Regular Height</code>和<code>Compact width-Compact Height</code>。</p>

<p>下图中的表格展示了不同iOS设备对应的<code>size classes</code>模型。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui21.png" alt="" /></p>

<p>为了描述真实的显示环境，你必须指定水平和竖直两个方向上的<code>size class</code>类型，以iPad为例，你应该指定它的<code>size class</code>为<code>Regular width-Regular Height</code>。</p>

<p>在自动布局的基础上，你可以为不同的<code>size classes</code>指定特定的布局约束，比如说，你可以为<code>size class</code>设为<code>compact height-regular width</code>的屏幕上的标签指定特定的字体大小，你也可以专门为<code>regular-regular</code>尺寸的屏幕改变一个按钮的位置。</p>

<p>需要注意的是，所有iPhone设备的竖向屏幕的<code>size class</code>都为<code>compact width-regular height</code>，这意味着你的界面在iPhone 4s和iPhone 6上竖屏展示的样子是几乎一样的。而对于iPhone 6 Plus的横屏来说，它的<code>size class</code>应该是<code>regular width-compact height</code>，这表示你的界面与在iPhone 4/5/6上的展示是完全不一样的。</p>

<p>对<code>Size Classes</code>的基本概念有过了解之后，我们接下来看看如何解决我们应用界面剩下的两个问题：</p>

<ul>
<li>标题标签不能被完整地显示，尤其是在iPhone设备上</li>
<li>产品描述标签在iPhone上也只是部分显示</li>
</ul>


<h2>使用Size Classes自定义字体大小</h2>

<p>我们想让标题标签和描述标签能在iPhone上完美显示，问题是现在字体的大小对于iPad来说很合适，但是对于iPhone来说它太大了。</p>

<p>使用<code>Size Classes</code>技术，你可以为不同尺寸的屏幕指定特定的字体大小。接下来，我们想要改变所有iPhone的竖屏界面内的字体大小，在<code>size classes</code>的表格中我们可以看出，它对应的<code>size class</code>应为<code>compact width-regular height</code>。</p>

<p>想要为不同尺寸设置不同的字体大小，首先在storyboard中选中我们的标题标签，在属性选项卡中<em>Font</em>选项左边，你会发现有一个加号按钮。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui22.png" alt="" /></p>

<p>点击加号按钮然后依次选择<code>compact width-regular height</code>，</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui23.png" alt="" /></p>

<p>然后你会发现新添加了一条<em>Font</em>选项专门用来设置你所指定的<code>size class</code>，保持原始的<em>Font</em>选项不变，我们只需将新的<em>Font</em>选项内的字体大小改为20。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui24.png" alt="" /></p>

<p>这样做的意思是通知系统，在所有iPhone设备的竖屏显示时，使用更小一点的字体大小，而在iPad上显示时，仍然使用我们早期设置的大小。接下来选择产品描述标签，同样更改它在<code>compact width-regular height</code>下的字体大小为13。查看预览视图，我们的文字已经能够完美地展示在不同设备上了。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui25.png" alt="" /></p>

<h2>使用Size Classes自定义界面的设计</h2>

<p>现在我们的界面已经适配所有的竖屏尺寸了，那么在横屏显示时，我们的界面又是如何展示的呢？</p>

<p>在预览窗口内，点击设备下部的旋转按钮（比如点击4英寸的iPhone）。很明显，我们的界面在iPhone的横屏上并不能很好的展示。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui26.png" alt="" /></p>

<p>你可能会想到我们可以为横屏尺寸的屏幕设置更小的字体，就跟我们之前做的一样，我并不打算这么去做。</p>

<p>我将重新设计横屏界面的布局来代替之前的设计，目的是为了更好的利用横屏模式下更宽的尺寸，这才是<code>Size Classes</code>技术能力的体现。</p>

<p>对于横屏界面来说，将产品图片视图和产品简介视图并排显示效果可能更好，并且每一个视图占据主视图的50%，我们的界面应该看上去像下图这样。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui27.png" alt="" /></p>

<p>到目前为止，我们并没有介绍<code>Size Classes</code>在视图布局上如何应用，我们之前设计的界面一直是在<code>wAny hAny</code>的<code>size class</code>下进行的。</p>

<p>现在，点击storyboard下方的<code>wAny hAny</code>按钮，在这里我们能够通过选择表格大小来指定不同的<code>size class</code>。我们想要更改iPhone设备横屏下的界面布局，所以我们选择<code>Any Width-Compact Height</code>，它代表了所有iPhone设备的横屏显示（包括iPhone 6 Plus）。</p>

<p>在表格中移动鼠标，选择<code>Any Width-Compact Height</code>的<code>size class</code>。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui28.png" alt="" /></p>

<p>当你选择特定的<code>size class</code>之后，控制器视图的尺寸也会发生相应的改变，在storyboard底部会标示出你当前所指定的<code>size class</code>为<em>wAny hCompact</em>，接下来你做的所有布局，都只会针对当前的<code>size class</code>，而不会影响到其他尺寸，这就是在Xcode中如何使用一个storyboard文件来展示多种界面布局的原理。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui29.png" alt="" /></p>

<p>好，接下来我们开始设计我们的界面。</p>

<p>当前的界面会将我们之前添加的布局约束保留下来（<code>size class</code>为<em>wAny hAny</em>的时候），因为我们接下来想要重新去布局我们的界面，所以我们应该先把之前的约束全部清空。</p>

<p>在大纲视图中选择主视图，然后点击自动布局菜单中的<em>Issues</em>按钮，然后选择<em>All Views</em>下面的<em>Clear Constraints</em>选项。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui30.png" alt="" /></p>

<p>这样会清空我们当前<code>size class</code>下的所有布局约束，注意那些约束在<em>wAny hAny</em>下仍然有效，我们只是将<em>wAny hCompact</em>下的所有约束给清空了。</p>

<p>你可以打开大纲视图展开约束列表，你会发现所有约束都还在只是变成了灰色，意味着当前<code>size class</code>下它们不可用。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui31.png" alt="" /></p>

<p>如果你选中任意一个约束，然后打开尺寸选项卡，你会发现有两个<em>Installed</em>复选框，而且<em>wAny hCompact</em>下的<em>Installed</em>没有被选中，而通用布局下的<em>Installed</em>被选中了，这验证了我们只是将当前<code>size class</code>下的约束给清除了，并没有影响其他尺寸下的布局约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui32.png" alt="" /></p>

<p>接下来，我们开始布局我们的新界面，让产品图片视图和产品简介视图并排显示在一行。</p>

<p>首先，选择产品图片视图，在尺寸选项卡下，设置X为0、Y为0、宽度为300、高度为400，然后选择产品简介视图，设置它的尺寸X为300、Y为0、宽度为300、高度为400，界面的效果应该像下图一样。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui33.png" alt="" /></p>

<p>接下来，选择标题标签，设置它的尺寸X为22、Y为15、宽度为256、高度为70，标题文字的字体太大了，所以我们要为当前<code>size class</code>下的字体设置特定的大小，在属性选项卡中，点击<em>Font</em>旁边的加号按钮，选择<em>Any Width | Compact Height (current)</em>选项。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui34.png" alt="" /></p>

<p>这样就新建了一个对当前<code>size class</code>下的字体设置，把它的大小改为25。现在我们的标题标签只能显示在一行里，将<em>Lines</em>属性从1改为0，标题标签会自动判断自己应该显示几行。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui35.png" alt="" /></p>

<p>选择产品描述标签，设置它的尺寸X为22、Y为85、宽度为256、高度为250，现在我们的界面应该如下图所示。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui36.png" alt="" /></p>

<p>因为我们之前已经把所有约束清空了，所以接下来我们必须为当前<code>size class</code>下的界面添加自动布局约束。</p>

<p>选择产品图片视图，点击<em>Pin</em>按钮，添加上边、左边、下边间距约束为0，记住不要选中<code>Constrain to margins</code>，然后点击添加三个约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui37.png" alt="" /></p>

<p>接下来选择产品简介视图，同样设置它的上边、右边、下边间距约束为0。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui38.png" alt="" /></p>

<p>在大纲视图内，按住<em>Control</em>键从主视图拖到产品图片视图，选择等宽约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui39.png" alt="" /></p>

<p>这条约束是要用来表示产品图片视图占据主视图的一半，就像之前我们将等高约束相乘系数改为0.65一样，这里我们把等宽约束的相乘系数改为0.5，这样产品图片视图就只占据主视图的50%了。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui40.png" alt="" /></p>

<p>接下来我们为产品图片视图和产品简介视图添加间距约束。在大纲视图中，按住<em>Control</em>键从产品图片视图拖到产品简介视图，在弹出的菜单中选择<em>竖向间距</em>约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui41.png" alt="" /></p>

<p>好了，现在我们搞定产品图片视图和产品简介视图的所有约束了，剩下的就是为两个标签添加约束了。</p>

<p>首先选择标题标签，设置它的约束为上边15、左边22、右边22，记住不要选中<code>Constrain to margins</code>选项。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui42.png" alt="" /></p>

<p>按住<em>Control</em>键从标题标签拖到产品描述标签，在弹出的菜单中选择<em>竖向间距</em>约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui43.png" alt="" /></p>

<p>选择产品描述标签，设置它的约束为左边22、右边22，记住不要选中<code>Constrain to margins</code>选项。</p>

<p>storyboard会提示我们现在的约束有些问题。在大纲视图中点击右上角的黄色箭头，然后点击黄色指示器按钮，然后选择<em>Update frame</em>选项来解决我们所有的布局问题。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui44.png" alt="" /></p>

<p>非常棒！现在再去预览视图中查看我们应用的界面在横屏下的显示，如下图所示。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui45.png" alt="" /></p>

<p>我们的界面看上去非常精美，对吧？然而在3.5和4英寸的iPhone上，产品描述标签的显示还有一些小问题。要解决这个问题，你需要新建一个针对这种情况下的<code>size class</code>的字体设置选项，我将这一步留给你们自行练习解决。</p>

<p>接下来，点击运行按钮使用模拟器运行我们的程序，当你将设备从竖屏旋转到横屏时，你会发现我们的界面在发生变化的过程中还带有非常平滑的转场动画。</p>

<h2>使用Size Classes自定义约束</h2>

<p>希望你现在已经理解如何使用<code>Size Classes</code>技术来自定义字体和自定义界面设计，除此之外，使用<code>Size Classes</code>技术还可以自定义约束。</p>

<p>如果我想让我们的界面在iPhone 6 Plus下展示成下图的样子，却不改变它在其他iPhone设备上的展示，那么我该如何去做呢？</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui46.png" alt="" /></p>

<p>从图中我们可以看到，标题标签和产品描述标签被移到了右下方，很明显，我们应该自定义标题标签同它的父视图（产品简介视图）之间的上边间距，让我们来看看应该如何去做。</p>

<p>iPhone 6 Plus横屏的<code>size class</code>应该为<code>Regular width-Compact Height</code>，在storyboard下方的<em>Size Classes</em>表格选项中选择<code>Regular width-Compact Height</code>并确认。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui47.png" alt="" /></p>

<p>在大纲视图中，找到标题标签同它父控件之间的竖向间距约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui48.png" alt="" /></p>

<p>在尺寸选项卡中，你可以在<em>Constant</em>选项旁边看到一个加号按钮，<em>Constant</em>的值现在被设置为15，我们希望在当前<code>size class</code>下增大这个间距，所以点击加号按钮，选择<code>Regular Width | Compact Height (current)</code>选项。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui49.png" alt="" /></p>

<p>在新建的<em>wR hC</em>选项中，将间距值设为230。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui50.png" alt="" /></p>

<p>如果你的大纲视图中显示存在布局约束问题，你可以点击箭头，然后根据Xcode的建议来解决约束问题。</p>

<p>再次在预览视图中查看我们的界面，你会发现5.5英寸的iPhone界面改变了，而其他iPhone设备上的界面并没有变化。</p>

<h2>总结</h2>

<p>在iOS 8和Xcode 6中，苹果为开发者提供了非常强大的工具来搭建自适应界面。在本文中，我们介绍了<code>Size Classes</code>技术和相关概念，并展示了如何搭建一个自适应的界面。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui51.png" alt="" /></p>

<p>自适应布局是iOS 8中一个非常重要的新特性，开发者只针对一种设备、一种屏幕尺寸去设计界面的日子不可能再有了，如果你正打算开发一款新的应用，确保你已经熟悉自动布局和<code>Size Classes</code>技术，从而让你的应用能够适配多种屏幕尺寸和方向，未来的应用界面肯定更需要自适应布局技术。</p>

<p>你可以在<a href="https://www.dropbox.com/s/j2dja7mck9rgfvd/AdaptiveUIDemo.zip?dl=0">这里</a>下载本教程的完整示例代码，供你学习和参考。（译注：原文资源文件地址需要FQ访问，本人已转存到GitHub上，详见<a href="https://github.com/WXGBridgeQ/AdaptiveUIDemo">这里</a>）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIScrollView新手教程 | AppCoda翻译系列]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/06/19/uiscrollview-tutorial/"/>
    <updated>2015-06-19T10:08:23+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/06/19/uiscrollview-tutorial</id>
    <content type="html"><![CDATA[<p>（本文翻译自AppCoda，详见：<a href="http://www.appcoda.com/uiscrollview-introduction/">原文链接：A Beginner’s Guide to UIScrollView</a>）</p>

<p>在iOS开发中，滚动视图（UIScrollView）通常用于显示内容尺寸大于屏幕尺寸的视图。滚动视图有以下两个主要作用：</p>

<ul>
<li><p>让用户可以通过拖拽手势来观看想看到的内容</p></li>
<li><p>让用户可以通过捏合手势来放大或缩小观看的内容</p></li>
</ul>


<p>在iOS应用中常见的表格视图（UITableView）就继承自滚动视图，并因此可以通过上下滚动来显示更多的内容。</p>

<p>在本篇教程中，我们将讨论滚动视图的诸多方面内容，主要包括：使用纯代码和可视化编程两种方式来创建一个滚动视图、实现滚动和缩放功能，以及如何嵌套使用滚动视图。</p>

<!--more-->


<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/uiscrollview-guide.jpg" alt="" /></p>

<p>继续阅读之前，请先下载本文示例代码所需的资源文件，详见：<a href="https://www.dropbox.com/s/qhdja7ixcfixu8e/UIScrollViewStarter.zip?dl=0">资源文件地址</a>。（译注：原文资源文件地址需要FQ访问，本人已转存到GitHub上，详见<a href="https://github.com/WXGBridgeQ/UIScrollViewStarter">这里</a>）</p>

<h2>使用纯代码方式创建UIScrollView</h2>

<p><code>UIScrollView</code>同其他视图一样，可以通过纯代码和可视化编程两种方式来创建。在创建之后，只需要少量额外设置就可以让<code>UIScrollView</code>获得基本的滚动功能。</p>

<p><code>UIScrollView</code>也和其他视图一样，应该被一个控制器管理或者添加到某个视图层级中。想要完成滚动功能还需要对<code>UIScrollView</code>进行以下两步设置：</p>

<ul>
<li><p>必须设置<code>UIScrollView</code>的<code>contentSize</code>属性，它提供了<code>UIScrollView</code>的内容的大小，也就是可以滚动的区域的大小。</p></li>
<li><p>必须为<code>UIScrollView</code>添加一个或多个用于显示和滚动的子视图，这些视图提供了<code>UIScrollView</code>显示的内容。</p></li>
</ul>


<p>你还可以根据应用的具体需求设置<code>UIScrollView</code>的一些显示效果，比如：是否显示水平和竖直方向的滚动条、滚动的弹性效果、缩放的弹性效果，以及允许的滚动方向等。</p>

<p>接下来我们将在代码中创建一个<code>UIScrollView</code>。在下载的资源文件中打开<code>ScrollViewDemo</code>工程。它就是一个简单的<code>Single View Application</code>工程，只不过将<code>storyboard</code>中根控制器的类型绑定为自己新建的叫做<code>ScrollViewController</code>的控制器，还在项目中添加了一张我们要用到的图片，图片名称为<code>image.png</code>。</p>

<p>接下来打开<code>ScrollViewController.swift</code>文件，添加如下代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">var</span> <span class="nl">scrollView</span><span class="p">:</span> <span class="bp">UIScrollView</span><span class="o">!</span>
</span><span class='line'><span class="n">var</span> <span class="nl">imageView</span><span class="p">:</span> <span class="bp">UIImageView</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>


<p>按如下代码所示修改<code>viewDidLoad()</code>方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">override</span> <span class="n">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">imageView</span> <span class="o">=</span> <span class="bp">UIImageView</span><span class="p">(</span><span class="nl">image</span><span class="p">:</span> <span class="bp">UIImage</span><span class="p">(</span><span class="nl">named</span><span class="p">:</span> <span class="s">&quot;image.png&quot;</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">scrollView</span> <span class="o">=</span> <span class="bp">UIScrollView</span><span class="p">(</span><span class="nl">frame</span><span class="p">:</span> <span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">)</span>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="bp">UIColor</span><span class="p">.</span><span class="n">blackColor</span><span class="p">()</span>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">contentSize</span> <span class="o">=</span> <span class="n">imageView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="o">=</span> <span class="n">UIViewAutoresizing</span><span class="p">.</span><span class="n">FlexibleWidth</span> <span class="o">|</span> <span class="n">UIViewAutoresizing</span><span class="p">.</span><span class="n">FlexibleHeight</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">imageView</span><span class="p">)</span>
</span><span class='line'>    <span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">scrollView</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上述代码创建了一个<code>UIScrollView</code>和<code>UIImageView</code>，<code>UIImageView</code>被设置为<code>UIScrollView</code>的子视图。<code>contentSize</code>属性控制滚动区域的大小，我们将它设置为跟图片的尺寸一样大（2000×1500）。我们将滚动视图的背景色设置为黑色，这样图片就像在一块黑色幕布上滚动一样。我们将滚动视图的<code>autoresizingMask</code>属性设置为<code>.FlexibleWidth</code>和<code>.FlexibleHeight</code>，使它能够在设备旋转之后自动适应新的宽度和高度。运行当前应用，你已经可以通过拖拽手势来滚动显示图片了。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image00.png" alt="" /></p>

<p>当你启动应用后，你会发现图片初始显示区域是它左上角的部分。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image01.png" alt="" /></p>

<p>这是因为滚动视图的<code>bounds</code>的起点默认为(0, 0)，代表了左上角。如果你想改变启动后显示的位置，你需要更改滚动视图的<code>bounds</code>的起点。因为这种需求经常被提起，所以<code>UIScrollView</code>专门提供了一个属性<code>contentOffset</code>用来实现这种需求。</p>

<p>在代码中添加如下语句，注意添加在设置autoresizingMask语句之后。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">scrollView</span><span class="p">.</span><span class="n">contentOffset</span> <span class="o">=</span> <span class="bp">CGPoint</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mi">450</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>重新运行应用，你会发现一开始就会显示图片的另一部分而不是左上角。你可以通过这种方式来决定程序启动后将要显示的内容。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image02.png" alt="" /></p>

<h2>缩放</h2>

<p>我们已经添加了一个<code>UIScrollView</code>，并且能够让用户通过拖拽来观看尺寸大于屏幕尺寸的内容。相当棒，但如果视图能够缩放的话会带来更好的体验。</p>

<p>要支持缩放功能，你必须为<code>UIScrollView</code>设置一个代理，而且代理必须遵守<code>UIScrollViewDelegate</code>协议，代理还需要实现<code>viewForZoomingInScrollView()</code>方法，该方法返回想要被缩放的视图。</p>

<p>你还应该为缩放设置一个比例，可以通过<code>UIScrollView</code>的<code>minimumZoomScale</code>和<code>maximumZoomScale</code>这两个属性来实现，它们的默认值都是1.0。</p>

<p>按照如下代码更改<code>ScrollViewController</code>的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">ScrollViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="bp">UIScrollViewDelegate</span> <span class="p">{</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后添加如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">viewForZoomingInScrollView</span><span class="p">(</span><span class="nl">scrollView</span><span class="p">:</span> <span class="bp">UIScrollView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">UIView</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">imageView</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来在<code>viewDidLoad()</code>方法的最后添加如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">scrollView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span>   
</span><span class='line'><span class="n">scrollView</span><span class="p">.</span><span class="n">minimumZoomScale</span> <span class="o">=</span> <span class="mf">0.1</span>
</span><span class='line'><span class="n">scrollView</span><span class="p">.</span><span class="n">maximumZoomScale</span> <span class="o">=</span> <span class="mf">4.0</span>
</span><span class='line'><span class="n">scrollView</span><span class="p">.</span><span class="n">zoomScale</span> <span class="o">=</span> <span class="mf">1.0</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上述代码中，我们设置了<code>zoomScale</code>为1.0，然后设置了缩放的最大和最小比例。在程序运行后，会按照图片的原始尺寸显示（因为<code>zonmScale</code>为1.0），当你使用捏合手势来操作图片时，你会发现图片可以被缩放了。我们设置了<code>maximumZoomScale</code>为4.0，所以图片最大只能放大到4倍。你也会发现，图片放大4倍后会变得很模糊，所以接下来我们会把它的缩放比例重新设置为1.0。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image03.png" alt="" /></p>

<p>从上面的图片中我们可以发现，我们之前将<code>minimumZoomScale</code>设置为0.1实在是太小了，屏幕空出了很多空闲的地方。在横屏模式下，空闲的区域看上去更大。我们希望图片能在某一方向上能与屏幕相匹配，让图片既能完全显示，又能尽量减少屏幕的空闲空间。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image04.png" alt="" /></p>

<p>要达到这样的效果，你必须通过图片尺寸和<code>UIScrollView</code>的尺寸来计算最小的缩放比例。</p>

<p>首先在<code>viewDidLoad()</code>方法中删除以下三行代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">scrollView</span><span class="p">.</span><span class="n">minimumZoomScale</span> <span class="o">=</span> <span class="mf">0.1</span>
</span><span class='line'><span class="n">scrollView</span><span class="p">.</span><span class="n">maximumZoomScale</span> <span class="o">=</span> <span class="mf">4.0</span>
</span><span class='line'><span class="n">scrollView</span><span class="p">.</span><span class="n">zoomScale</span> <span class="o">=</span> <span class="mf">1.0</span>
</span></code></pre></td></tr></table></div></figure>


<p>在控制器类中添加如下方法。在方法中，我们算出图片同<code>UIScrollView</code>的高度和宽度的比值，并将最小缩放比例设置为两者中更小的那个。注意，我们已经删除了<code>maximumZoomScale</code>的设置，所以它的默认值为1.0。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">setZoomScale</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">imageViewSize</span> <span class="o">=</span> <span class="n">imageView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">scrollViewSize</span> <span class="o">=</span> <span class="n">scrollView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">widthScale</span> <span class="o">=</span> <span class="n">scrollViewSize</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="n">imageViewSize</span><span class="p">.</span><span class="n">width</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">heightScale</span> <span class="o">=</span> <span class="n">scrollViewSize</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="n">imageViewSize</span><span class="p">.</span><span class="n">height</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">minimumZoomScale</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">widthScale</span><span class="p">,</span> <span class="n">heightScale</span><span class="p">)</span>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">zoomScale</span> <span class="o">=</span> <span class="mf">1.0</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在<code>viewDidLoad()</code>方法最后调用这个方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">setZoomScale</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>在<code>viewWillLayoutSubviews()</code>方法中也需要调用该方法，这样当用户改变屏幕方向后，图片的尺寸仍然是正确的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">override</span> <span class="n">func</span> <span class="nf">viewWillLayoutSubviews</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">setZoomScale</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行程序，现在你会发现无论你缩放到多小，图片都会完整显示并且尽量占满剩余的空间。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image05.png" alt="" /></p>

<p>我们可以发现，图片是被定位在屏幕左上角的，我们希望将它放在屏幕中间。</p>

<p>在代码中添加如下方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">scrollViewDidZoom</span><span class="p">(</span><span class="nl">scrollView</span><span class="p">:</span> <span class="bp">UIScrollView</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">imageViewSize</span> <span class="o">=</span> <span class="n">imageView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">scrollViewSize</span> <span class="o">=</span> <span class="n">scrollView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">let</span> <span class="n">verticalPadding</span> <span class="o">=</span> <span class="n">imageViewSize</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;</span> <span class="n">scrollViewSize</span><span class="p">.</span><span class="n">height</span> <span class="o">?</span> <span class="p">(</span><span class="n">scrollViewSize</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">imageViewSize</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">horizontalPadding</span> <span class="o">=</span> <span class="n">imageViewSize</span><span class="p">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">scrollViewSize</span><span class="p">.</span><span class="n">width</span> <span class="o">?</span> <span class="p">(</span><span class="n">scrollViewSize</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">imageViewSize</span><span class="p">.</span><span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">scrollView</span><span class="p">.</span><span class="n">contentInset</span> <span class="o">=</span> <span class="bp">UIEdgeInsets</span><span class="p">(</span><span class="nl">top</span><span class="p">:</span> <span class="n">verticalPadding</span><span class="p">,</span> <span class="nl">left</span><span class="p">:</span> <span class="n">horizontalPadding</span><span class="p">,</span> <span class="nl">bottom</span><span class="p">:</span> <span class="n">verticalPadding</span><span class="p">,</span> <span class="nl">right</span><span class="p">:</span> <span class="n">horizontalPadding</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法在缩放的时候就会被调用，它会通知代理<code>UIScrollView</code>的缩放比例发生改变了。在上面的方法中，我们计算了图片在滚动视图中的内间距，从而使图片始终在屏幕的中间。对于上、下方向的内边距，我们首先判断图片视图的高度是否小于滚动视图的高度，如果是就将边距设为两者的差值的一半，否则设为0。水平间距我们采用同样的方式计算。然后通过<code>contentInset</code>属性设置所有方向的内边距，这个属性代表了<code>UIScrollView</code>的内容距离<code>UIScrollView</code>本身四周的距离。</p>

<p>运行程序，你会发现当你缩小图片时，图片始终保持在屏幕的中间。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image06.png" alt="" /></p>

<h2>通过双击来缩放</h2>

<p><code>UIScrollView</code>默认只支持通过捏合手势来实现缩放效果，如果想实现通过双击来缩放，则需要自己做些额外的设置。</p>

<p><code>iOS人机界面指南</code>中介绍了可以通过双击手势来达到缩放的效果。使用双击手势进行缩放需要一定的前提：要缩放的视图只能在最大和最小比例两个固定值之间来回缩放，就像苹果官方的相册应用一样，当你双击图片时，图片放大至最大，当你再次双击时，图片缩小至最小，或者可以通过连续的双击使视图一点点达到最大，然后再次双击的时候，将视图恢复为全屏显示。但是大多数应用需要实现更灵活的双击缩放效果，例如地图应用，当你双击时会使其放大，继续双击会继续放大，想要缩小则可以使用双指捏合手势来实现。</p>

<p>要想在你的程序中实现双击缩放功能，你需要监听<code>UIScrollView</code>的手势并进行处理。在我们的程序中，我们将模仿苹果官方的相册应用的效果，当你双击时放大到最大值，再次双击时则缩小到最小值。</p>

<p>在代码中添加如下两个方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">setGestureRecognizer</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">doubleTap</span> <span class="o">=</span> <span class="bp">UITapGestureRecognizer</span><span class="p">(</span><span class="nl">target</span><span class="p">:</span> <span class="nb">self</span><span class="p">,</span> <span class="nl">action</span><span class="p">:</span> <span class="s">&quot;handleDoubleTap:&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">doubleTap</span><span class="p">.</span><span class="n">numberOfTapsRequired</span> <span class="o">=</span> <span class="mi">2</span>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">addGestureRecognizer</span><span class="p">(</span><span class="n">doubleTap</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">func</span> <span class="nf">handleDoubleTap</span><span class="p">(</span><span class="nl">recognizer</span><span class="p">:</span> <span class="bp">UITapGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">scrollView</span><span class="p">.</span><span class="n">zoomScale</span> <span class="o">&gt;</span> <span class="n">scrollView</span><span class="p">.</span><span class="n">minimumZoomScale</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">scrollView</span><span class="p">.</span><span class="n">setZoomScale</span><span class="p">(</span><span class="n">scrollView</span><span class="p">.</span><span class="n">minimumZoomScale</span><span class="p">,</span> <span class="nl">animated</span><span class="p">:</span> <span class="nb">true</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">scrollView</span><span class="p">.</span><span class="n">setZoomScale</span><span class="p">(</span><span class="n">scrollView</span><span class="p">.</span><span class="n">maximumZoomScale</span><span class="p">,</span> <span class="nl">animated</span><span class="p">:</span> <span class="nb">true</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在<code>viewDidLoad()</code>方法最后调用上面的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">setGestureRecognizer</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，我们为<code>UIScrollView</code>添加了一个双击手势的监听，然后根据图片当前的缩放比例，来判断是将图片放大或者缩小。</p>

<p>运行程序，你会发现已经能通过双击手势来缩放图片了。</p>

<h2>用可视化编程方式创建UIScrollView</h2>

<p>使用<code>storyboard</code>可以实现和我们上面使用代码方式实现的同样的功能，而且更为简单，代码量更少。</p>

<p>在<code>Main.storyboard</code>文件中，拖一个新的视图控制器，并将其设置为初始控制器（既可以将箭头拖到新控制器上，也可以在属性选项卡中选中<code>Is Initial View Controller</code>复选框）。</p>

<p>拖一个<code>UIScrollView</code>到新的控制器中，然后设置其边缘始终粘着屏幕。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image07.png" alt="" /></p>

<p>然后拖一个<code>UIImageView</code>到刚才的<code>UIScrollView</code>中，将它的边缘设置为粘着<code>UIScrollView</code>。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image08.png" alt="" /></p>

<p>要记住<code>UIScrollView</code>需要知道它的内容的大小，才可以实现滚动。当你为<code>UIImageView</code>设置图片时，<code>UIScrollView</code>的内容大小就会被自动设置为图片的大小。</p>

<p>在<code>UIImageView</code>的属性选项卡中，将<code>Image</code>属性设置为<code>image.png</code>，然后通过<code>updating the frames</code>解决自动布局的问题。运行程序，你会发现已经实现图片的滚动显示了，并且没有敲一行代码。你还可以在<code>UIScrollView</code>的属性选项卡中查看还有哪些属性可以设置，比如可以设置最大和最小的缩放比例。</p>

<p>如果想要实现缩放功能，你仍然需要通过代码，设置代理并实现<code>viewForZoomingInScrollView()</code>方法，同我们之前做过的一样，就不再重复一遍了。</p>

<h2>UIScrollView的嵌套使用</h2>

<p>可以在一个<code>UIScrollView</code>中嵌套另一个<code>UIScrollView</code>，两个<code>UIScrollView</code>既可以是相同方向滚动的，也可以是不同方向的。这部分内容的示例代码请使用<code>NestedScrollViews</code>项目。</p>

<h4>相同方向的UIScrollView嵌套</h4>

<p>相同方向的<code>UIScrollView</code>嵌套是指一个<code>UIScrollView</code>，它有另一个<code>UIScrollView</code>作为子控件，并且它们的滚动方向一致。你可以用相同方向的嵌套来实现这样的效果，比如在<code>UIScrollView</code>中添加多组要区分开的数据，你还可以通过它来实现两个<code>UIScrollView</code>同时滚动时的视差效果。在我们的示例中，我们将两个相同方向的<code>UIScrollView</code>设置不同的滚动速度，从而实现滚动时的视差效果。</p>

<p>打开<code>NestedScrollViews</code>项目中的<code>storyboard</code>文件，你将看到两个<code>UIScrollView</code>，分别叫做foreground和background。background里面添加了一个<code>UIImageView</code>，并将图片设置为<code>image.png</code>，foreground里面添加了一些标签和一个作为容器用的<code>UIVIew</code>，这些标签只是为了方便我们观看视图的滚动，容器视图我们将在下一节内容中才用到。</p>

<p>我们的界面这样就算搭建完成了，现在运行程序的话，你会发现只有foreground视图在滚动，而background视图保持不动。接下来我们将要实现background的滚动，并且实现滚动的视差效果。</p>

<p>首先将foreground和background两个<code>UIScrollView</code>连线到控制器，之后代码会如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">@</span><span class="kt">IBOutlet</span> <span class="k">weak</span> <span class="n">var</span> <span class="nl">background</span><span class="p">:</span> <span class="bp">UIScrollView</span><span class="o">!</span>
</span><span class='line'><span class="p">@</span><span class="kt">IBOutlet</span> <span class="k">weak</span> <span class="n">var</span> <span class="nl">foreground</span><span class="p">:</span> <span class="bp">UIScrollView</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们需要知道foreground视图滚动了多长的距离，用来计算background视图需要滚动多长的距离。所以我们需要为foreground视图设置一个代理，用来监听它的滚动。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="nl">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="bp">UIScrollViewDelegate</span> <span class="p">{</span>
</span></code></pre></td></tr></table></div></figure>


<p>在<code>viewDidLoad()</code>方法中设置foreground视图的代理。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">foreground</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后实现如下代理方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">scrollViewDidScroll</span><span class="p">(</span><span class="nl">scrollView</span><span class="p">:</span> <span class="bp">UIScrollView</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">foregroundHeight</span> <span class="o">=</span> <span class="n">foreground</span><span class="p">.</span><span class="n">contentSize</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">CGRectGetHeight</span><span class="p">(</span><span class="n">foreground</span><span class="p">.</span><span class="n">bounds</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">percentageScroll</span> <span class="o">=</span> <span class="n">foreground</span><span class="p">.</span><span class="n">contentOffset</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">foregroundHeight</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">backgroundHeight</span> <span class="o">=</span> <span class="n">background</span><span class="p">.</span><span class="n">contentSize</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">CGRectGetHeight</span><span class="p">(</span><span class="n">background</span><span class="p">.</span><span class="n">bounds</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">background</span><span class="p">.</span><span class="n">contentOffset</span> <span class="o">=</span> <span class="bp">CGPoint</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">backgroundHeight</span> <span class="o">*</span> <span class="n">percentageScroll</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，我们获取了foreground视图可以滚动的最大高度，然后用当前滚动的距离除以它以获取滚动的比例，然后获取background视图可以滚动的最大高度，将其乘以滚动比例，就可以得到background应该滚动的距离。运行你的程序，在进行滚动时你会发现foreground和background两个视图都在滚动，并且background视图滚动的更快，从而有一种视差效果。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/sv01.gif" alt="" /></p>

<h4>交叉方向的UIScrollView嵌套</h4>

<p>交叉方向的<code>UIScrollView</code>嵌套是指一个<code>UIScrollView</code>，它有另一个<code>UIScrollView</code>作为子控件，并且它们的滚动方向正好相差90°，接下来我们就演示一下这种情况。</p>

<p>在<code>NestedScrollViews</code>项目中，你会发现在foreground里面有一个<code>Container View</code>，我们将用它来设置我们水平滚动的<code>UIScrollView</code>。</p>

<p>在<code>storyboard</code>中新拖入一个控制器，按住Control键从<code>Container View</code>拖到新的控制器，选择<em>embed</em>方式。然后选中这个控制器，将它的Size选项设为<em>Freeform</em>并将其高度设为128，因为<code>Container View</code>的高度就是128。</p>

<p>往新控制器中拖入一个<code>UIScrollView</code>，设置其边缘始终粘着父控件。然后在<code>UIScrollView</code>中拖入一个70×70的<code>UIView</code>，将其背景色设为灰色方便我们观看，然后复制多个，从左到右依次摆放在<code>UIScrollView</code>中。你不需要精确地去设置每一个<code>UIView</code>的位置，接下来我会教你们怎么去做。现在我们的控制器界面应该是这个样子。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image12.png" alt="" /></p>

<p>选择最左边的<code>UIView</code>，添加它上边和左边的约束，再添加宽度和高度约束。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image13.png" alt="" /></p>

<p>再选择最右边的<code>UIView</code>，添加它的上边、右边、宽度和高度约束。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image14.png" alt="" /></p>

<p>接下来，选中我们的<code>UIScrollView</code>，然后点击上面菜单栏中的<code>Editor &gt; Resolve Auto Layout Issues &gt; All Views &gt; Add Missing Constraints</code>。这样我们所有的<code>UIView</code>就都添加好了约束。运行你的程序，竖直滚动到底部，你会看见我们的<code>Container View</code>，你可以水平滚动它里面的内容。下图中，我将控制器自身视图的背景色设置为透明，所以你看到的效果就是这样的。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/sv02.gif" alt="" /></p>

<p>我们的教程这就结束了，并没有包含<code>UIScrollView</code>所有的方方面面，但我希望通过这篇教程可以让你对<code>UIScrollView</code>有初步的了解，更多<code>UIScrollView</code>的知识，你可以查看苹果的官方文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/WindowsViews/Conceptual/UIScrollView_pg/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008179-CH1-SW1">Scroll View Programming Guide</a>。</p>

<p>你可以在<a href="https://www.dropbox.com/s/91buj9d9gmphoen/UIScrollViewFinal.zip?dl=0">这里</a>下载完整的示例程序作为学习参考。（译注：原文资源文件地址需要FQ访问，本人已转存到GitHub上，详见<a href="https://github.com/WXGBridgeQ/UIScrollViewFinal">这里</a>）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Effective Objective-C 读书笔记(一)]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/05/16/effective-oc-note-first/"/>
    <updated>2015-05-16T16:30:39+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/05/16/effective-oc-note-first</id>
    <content type="html"><![CDATA[<h2>OC的消息机制</h2>

<p>OC与其他面向对象语言如C++、Java的不同之处在于使用消息机制代替方法调用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// OC</span>
</span><span class='line'><span class="bp">NSObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSObject</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">obj</span> <span class="n">doSomething</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Java</span>
</span><span class='line'><span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Object</span><span class="p">();</span>
</span><span class='line'><span class="n">obj</span><span class="p">.</span><span class="n">doSomething</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>两者关键区别在于：在使用方法调用的语言中，程序运行时所应执行的代码多数情况下在编译时期就已经被确定，只有在多态的情况下才会在运行时查看该调用哪段代码。而在OC中，无论是否多态，程序运行时所应执行的代码都是由运行时环境来决定。所以在OC中，编译器并不关心接收消息的对象是何种类型，所有消息也都在运行时才被处理，也就是OC的动态绑定机制。</p>

<!--more-->


<h2>@class的使用</h2>

<p>如果在一个类<code>SomeClass</code>的声明中引用了另一个类<code>OtherClass</code>，最简单的做法可能是使用<code>#import "OtherClass.h"</code>导入这个类，然而这并不是最好的做法。<br/>
假设<code>SomeClass</code>又被许多其他类引用，那么每次引用<code>SomeClass</code>的时候都会同时引用<code>OtherClass</code>，这会降低一定的编译性能。更好的做法是在声明文件中将<code>#import "OtherClass.h"</code>改为<code>@class OtherClass;</code>，在具体使用<code>OtherClass</code>的文件如<code>SomeClass.m</code>中，才使用<code>#import "OtherClass.h"</code>导入这个类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// SomeClass.h</span>
</span><span class='line'><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// #import &quot;OtherClass.h&quot;</span>
</span><span class='line'><span class="k">@class</span> <span class="nc">OtherClass</span>;
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">SomeClass</span> : <span class="bp">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">)</span> <span class="n">OtherClass</span> <span class="o">*</span> <span class="n">other</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种做法叫做<code>向前声明</code>，向前声明还可以解决两个类相互循环引用的问题。</p>

<p>向前声明并不是所有情况都适用，当一个类需要继承自某个父类时，就必须在声明中导入父类的头文件。同样，当一个类需要遵守某个协议时，也必须导入协议的头文件。</p>

<h2>字面量语法的使用</h2>

<p>Foundation框架中的这几个类<code>NSString、NSNumber、NSArray、NSDictionary</code>都有相应的字面量语法，具体使用如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">@&quot;some string&quot;</span><span class="p">;</span>
</span><span class='line'><span class="bp">NSNumber</span> <span class="o">*</span><span class="n">num</span> <span class="o">=</span> <span class="mi">@10</span><span class="p">;</span>
</span><span class='line'><span class="bp">NSArray</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="l">@[</span><span class="s">@&quot;some string&quot;</span><span class="p">,</span> <span class="mi">@10</span><span class="l">]</span><span class="p">;</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">someString</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSDictionary</span> <span class="o">*</span><span class="n">dic</span> <span class="o">=</span> <span class="l">@{</span><span class="s">@&quot;key1&quot;</span> <span class="o">:</span> <span class="s">@&quot;value1&quot;</span><span class="p">,</span> <span class="s">@&quot;key2&quot;</span> <span class="o">:</span> <span class="s">@&quot;value2&quot;</span><span class="l">}</span><span class="p">;</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="s">&quot;key1&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用字面量语法不仅可以使代码简洁、可读性强，在数组和字典的创建过程中，还有一个小小的优点。</p>

<p>使用字面量语法创建数组其实本质也是调用<code>NSArray</code>类的<code>arrayWithObjects:</code>方法，前面arr数组的创建等价于如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSArray</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSArray</span> <span class="nl">arrayWithObjects</span><span class="p">:</span><span class="s">@&quot;some string&quot;</span><span class="p">,</span> <span class="mi">@10</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用<code>arrayWithObjects:</code>方法创建数组时，如果数组元素中有<code>nil</code>，会提前结束方法，不会抛出异常。这样会导致数组元素与逻辑不符，却很难发现代码错误。<br/>
而使用字面量语法创建数组时，如果数组元素中有<code>nil</code>，则会抛出异常，这样有利于程序员提前发现代码错误。</p>

<h2>用类型常量代替#define预处理指令</h2>

<p>写代码时经常遇到需要使用常量的地方，一般都不推荐直接使用数字，因为它既显得突兀又不利于代码的维护，通常我们有两种办法来定义常量，一种是使用<code>#define</code>预处理命令，另一种是使用<code>static const</code>关键字来定义一个常量。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#define ANIMATION_DURATION 0.3</span>
</span><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="n">NSTimeInterval</span> <span class="n">kAnimationDuration</span> <span class="o">=</span> <span class="mf">0.3</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用<code>#define</code>预处理命令仅仅是将代码中的<code>ANIMATION_DURATION</code>字符串替换为0.3，这样定义的常量并不具备类型信息，因此无法使用编译器带给我们的诸多好处，所以更推荐使用第二种方式定义常量。</p>

<p>使用<code>static const</code>关键字来定义常量，用在类的实现文件中，则此常量只作用在本类中，其他类无法使用。如果多个类都需使用到某一常量，则需将常量定义成公开的，具体方式是在类的声明文件中使用<code>extern const</code>关键字声明常量，在类的实现文件中使用<code>const</code>关键字定义常量，这样任何类只要导入了声明常量的头文件就可以直接使用定义好的常量了。</p>

<p>需要注意的是，OC中没有命名空间的概念，是不允许有多个同名的全局变量存在的，因此定义公共的常量最好遵守一定的命名规则，通常是使用类名作为前缀，如<code>WXGViewAnimationDuration</code>。</p>

<h2>善用枚举类型来增强代码的可读性</h2>

<p>OC的系统框架中，大规模使用了枚举类型，苹果官方也推荐开发者更多去使用枚举类型来表达一系列常量。这样做的好处是使代码更具可读性，通过枚举中每个成员的名字可以很清楚地明白它所代表的意义。</p>

<p>可以使用<code>typedef</code>关键字定义枚举类型，来省去每次使用枚举类型时都需要加上<code>enum</code>关键字的麻烦。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">enum</span> <span class="n">ConnectionState</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">ConnectionStateDisconnected</span><span class="p">,</span>
</span><span class='line'>  <span class="n">ConnectionStateConnecting</span><span class="p">,</span>
</span><span class='line'>  <span class="n">ConnectionStateConnected</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="k">enum</span> <span class="n">ConnectionState</span> <span class="n">ConnectingState</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于多选枚举情况，可以使用按位操作来定义枚举值，这样在使用时就可以通过<code>|或&amp;</code>来控制枚举的选项。</p>

<p>苹果官方还定义了两个宏，用来快速定义使用自定义变量类型的枚举，我们也应该更多的使用这两个宏来定义自己的枚举。具体使用参考如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">,</span> <span class="n">UIViewAnimationTransition</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIViewAnimationTransitionNone</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationTransitionFlipFromLeft</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationTransitionFlipFromRight</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationTransitionCurlUp</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationTransitionCurlDown</span><span class="p">,</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="nf">NS_OPTIONS</span><span class="p">(</span><span class="bp">NSUInteger</span><span class="p">,</span> <span class="n">UIViewAutoresizing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIViewAutoresizingNone</span>                 <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAutoresizingFlexibleLeftMargin</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAutoresizingFlexibleWidth</span>        <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAutoresizingFlexibleRightMargin</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAutoresizingFlexibleTopMargin</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAutoresizingFlexibleHeight</span>       <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAutoresizingFlexibleBottomMargin</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>枚举类型还经常用在<code>switch</code>分支选择上，这种情况下最好不要在<code>case</code>语句中加上<code>default</code>选项，意义在于当枚举中有新成员加入后，因为没有遍历所有可能情况，编译器就会发出警告，从而确保<code>switch</code>语句能够正确处理所有情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Octopress搭建个人博客]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/05/15/octopress-personal-blog/"/>
    <updated>2015-05-15T11:51:37+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/05/15/octopress-personal-blog</id>
    <content type="html"><![CDATA[<p>作为一个iOS开发的新人，学习过程中看了许多大牛的技术博客，也聆听过多次<strong>每一个程序员都应该维护一个个人技术博客</strong>之类的教导，按耐不住终于决定开始搭建自己的个人学习博客。</p>

<p>关于动态网站的搭建，需要学习网站前端、服务器端和后台数据库等技术，配合一些大公司提供的云服务，完全可以实现免费搭建自己的网站，当然如果数据或者访问量过大就需要付费来提升服务质量了。</p>

<p>本文想讨论的是另一种看上去<code>反(geng)潮(zhuang)流(bi)</code>的做法，使用静态网页生成工具配合<a href="https://pages.github.com/">GitHub Pages</a>来搭建个人博客。<a href="http://jekyllrb.com/">Jekyll</a>应该是一个比较好的选择，<a href="http://octopress.org/">Octopress</a>则是在Jekyll的基础上帮你省去了许多麻烦的配置过程。所以我最终的选择是使用Octopress和GitHub Pages来搭建我个人的学习博客。</p>

<!--more-->


<p>Octopress和GitHub Pages的使用都可以去查看官方文档来学习，地址如下：</p>

<ul>
<li><a href="http://octopress.org/docs/">Octopress</a></li>
<li><a href="https://pages.github.com/">GitHub Pages</a></li>
</ul>


<h2>准备工作</h2>

<p>GitHub Pages的创建其实很简单，只需要申请一个GitHub账号，然后创建一个名称为<code>github_username.github.io</code>的代码仓库即可，<code>github_username</code>指的是你GitHub账号的名称，这样你就可以拥有一个域名为<code>github_username.github.io</code>的个人页面了。</p>

<p>Octopress的安装需要以下前提条件：</p>

<ol>
<li>安装Git</li>
<li>安装Ruby 1.9.3及以上版本</li>
</ol>


<p>由于使用OS X最新的10.10系统，这两样系统都已经自带安装过了，省去了些许麻烦。</p>

<h2>安装Octopress</h2>

<p>Octopress的安装过程总结如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/imathis/octopress.git octopress
</span><span class='line'>cd octopress
</span><span class='line'>sudo gem install bundler
</span><span class='line'>bundle install
</span><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<p>过程中需要注意的是，可能需要将gem源修改为国内淘宝源。</p>

<blockquote><p>Ruby和RubyGem相关知识推荐到<a href="https://ruby-china.org/wiki">Ruby China社区</a>的wiki页面进行学习</p></blockquote>

<h2>配置Octopress</h2>

<p>安装完成后需要做的就是各种自定义配置工作，此部分工作可能略为繁琐。</p>

<p>首先需要修改的是<code>_config.yml</code>文件，它是Octopress的主配置文件。其中，你可以设置博客网站的标题、副标题、作者姓名等，各项参数具体意义详见<a href="http://octopress.org/docs/configuring/">官方文档</a>。</p>

<p>需要注意的是，其中<code>3rd Party Settings</code>这部分使用的第三方插件大多为国外服务，可能会造成网站访问延迟过高，比较好的解决办法就是将国外第三方插件服务全部关闭，选用国内同类替代服务产品。本文最后会有详细介绍。</p>

<p>除了主配置文件的修改之外，其他配置工作主要是修改一些自定义模板文件，此部分文件主要存放在<code>source/_includes</code>路径下。</p>

<p>其中需要注意的是<code>source/_includes/head.html</code>和<code>source/_includes/custom/head.html</code>这两个文件，将其中使用的googleapi替换为useso，原因同样是国内访问googleapi会严重影响网站的响应速度。此处感谢360提供的公共库服务，详情请进<a href="http://libs.useso.com">这里</a>。</p>

<p>其他自定义配置可以根据Octopress的<a href="http://octopress.org/docs">官方文档</a>自行摸索。</p>

<h2>部署Octopress</h2>

<p>将Octopress部署到GitHub Pages上非常简单，在<code>octopress</code>目录下执行<code>rake setup_github_pages</code>命令，然后输入之前创建的GitHub Pages的项目地址，地址可以使用SSH或HTTPS URL中的任意一种方式。其中，SSH的本机配置详见<a href="https://help.github.com/articles/generating-ssh-keys/">这里</a>。</p>

<p>之后就可以使用<code>rake deploy</code>命令，将每次写好的博客部署到GitHub Pages上了。</p>

<h2>发表博客</h2>

<p>在<code>octopress</code>目录下执行<code>rake new_post["文章标题"]</code>命令，会自动在<code>source/_posts</code>目录下产生对应名称的<code>markdown</code>文件（文章标题支持中文，但支持的不是很完美），然后使用任意Markdown编辑软件打开并编写文章即可。我选择的是<strong>Mou</strong>，如需了解请点<a href="http://25.io/mou/">这里</a>。</p>

<p>文章写好后，使用<code>rake generate</code>命令可以将<code>markdown</code>文件自动解析成静态网页，使用<code>rake preview</code>命令可以本地预览页面，使用<code>rake deploy</code>命令即可将新文章发表到GitHub Pages的博客上。</p>

<h2>高级配置</h2>

<h4>配置侧边栏</h4>

<p>在Octopress中配置侧边栏主要有两步操作，首先在<code>source/_includes/custom/asides</code>目录下新建一个html文件，然后将此文件路径添加到<code>_config.yml</code>文件的<code>default_asides</code>里面，注意文件的添加顺序。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>default_asides: [custom/asides/about.html, custom/asides/category.html, asides/recent_posts.html]</span></code></pre></td></tr></table></div></figure>


<p>Octopress要求添加的html文件必须写在&lt;section&gt;之间，并且使用&lt;h1&gt;作为标题。具体格式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;section&gt;
</span><span class='line'>  &lt;h1&gt;关于我的一些事&lt;/h1&gt;
</span><span class='line'>  &lt;p&gt;85后，石油行业工作者，编程爱好者，目前自学iOS开发中。&lt;/p&gt;
</span><span class='line'>  &lt;p&gt;新浪微博：&lt;a href="http://weibo.com/u/3194218471/" target="_blank"&gt;我是乔&lt;/a&gt;&lt;/p&gt;
</span><span class='line'>&lt;/section&gt;</span></code></pre></td></tr></table></div></figure>


<h4>在侧边栏中显示文章分类</h4>

<p>新版本的Octopress默认已经支持文章分类的生成，只要在每篇文章头部的<code>categories</code>声明里填写分类名称即可。</p>

<p>如果想将文章分类显示到侧边栏中，做法参见上面的侧边栏配置。只不过在新建的<code>category.html</code>文件中，应填写如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 下面代码中大括号是全角的，如果复制，请自行改为半角
</span><span class='line'>&lt;section&gt;
</span><span class='line'>  &lt;h1&gt;文章分类&lt;/h1&gt;
</span><span class='line'>  &lt;ul id="categories"&gt;
</span><span class='line'>    ｛% for category in site.categories %｝
</span><span class='line'>      &lt;li class="category"&gt;
</span><span class='line'>        &lt;a&gt;｛｛ category | first | category_link ｝｝ (｛｛ category | last | size ｝｝)&lt;/a&gt;
</span><span class='line'>      &lt;/li&gt;
</span><span class='line'>    ｛% endfor %｝
</span><span class='line'>  &lt;/ul&gt;
</span><span class='line'>&lt;/section&gt;</span></code></pre></td></tr></table></div></figure>


<p>网上能搜索到的为Octopress添加分类功能的文章大多已经过时，还是推荐使用此段代码。</p>

<h4>分享、评论功能</h4>

<p>作为个人博客，分享和评论功能还是非常需要的，Octopress默认提供的全部都是国外服务，比如Facebook、Twitter、Google Plus、Disqus Comments等，不是很适合国内使用，接下来我们使用国内的分享、评论插件来替换。这里我选择的是<a href="http://www.jiathis.com">JiaThis</a>和<a href="http://www.uyan.cc">友言</a>。</p>

<p>具体的添加过程也比较简单，我是参考了唐巧大神的这篇博客：
<a href="http://www.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">像写程序一样写博客：搭建基于github的博客</a>。</p>

<ul>
<li>首先，在<code>_config.yml</code>文件中增加一项：<code>weibo_share: true</code></li>
<li>修改<code>source/_includes/post/sharing.html</code>文件，增加如下代码：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 下面代码中大括号是全角的，如果复制，请自行改为半角
</span><span class='line'>｛% if site.weibo_share %｝
</span><span class='line'>  ｛% include post/weibo.html %｝
</span><span class='line'>｛% endif %｝</span></code></pre></td></tr></table></div></figure>


<ul>
<li>访问<a href="http://www.jiathis.com">JiaThis</a>，获取分享功能代码</li>
<li>访问<a href="http://www.uyan.cc">友言</a>，获取评论功能代码</li>
<li>将以上两步的代码都加入到<code>weibo.html</code>中即可</li>
</ul>


<h2>写在最后</h2>

<p>终于完成了个人学习博客的搭建，整个过程自己研究了三天之久，当然收获也是不少，基本全写在这篇文章里了。</p>

<p>接下来的时间会将自己iOS开发的学习过程记录下来，作为自己复习总结的一个过程，也作为一份分享留给大家，希望写博客真像那些大牛们说的一样，能给自己带来一份快乐和满意。</p>

<p>最后的最后，推荐另外一篇唐巧大神的博客：
<a href="http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/">将博客从GitHub迁移到GitCafe</a>。</p>
]]></content>
  </entry>
  
</feed>
