<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[文章分类：技术文章翻译 | BridgeQ的个人学习博客]]></title>
  <link href="http://wxgbridgeq.github.io/blog/categories/ji-zhu-wen-zhang-fan-yi/atom.xml" rel="self"/>
  <link href="http://wxgbridgeq.github.io/"/>
  <updated>2018-09-26T22:53:03+08:00</updated>
  <id>http://wxgbridgeq.github.io/</id>
  <author>
    <name><![CDATA[BridgeQ]]></name>
    <email><![CDATA[wxg.bridgeq@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自定义控制器转场动画及下拉菜单的小Demo | AppCoda翻译系列]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/08/10/custom-transition-animation/"/>
    <updated>2015-08-10T22:19:36+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/08/10/custom-transition-animation</id>
    <content type="html"><![CDATA[<p>本文翻译总结自AppCoda以下两篇文章：</p>

<ul>
<li><a href="http://www.appcoda.com/custom-view-controller-transitions-tutorial/">Introduction to Custom View Controller Transitions and Animations</a></li>
<li><a href="http://www.appcoda.com/slide-down-menu-swift/">Creating a Slide Down Menu Using View Controller Transition</a></li>
</ul>


<p>iOS 7开始，苹果为开发者提供了自定义控制器转场动画相关的API，而实现该功能需要以下三个步骤：</p>

<ul>
<li>创建一个类作为动画管理器，该类需继承自NSObject并遵守UIViewControllerAnimatedTransitioning协议，我们在这个类中编写我们的动画执行代码。</li>
<li>为目标控制器指定转场动画代理，既可以使用上一步创建的动画管理器对象，也可以指定来源控制器作为这个代理。</li>
<li>实现代理协议中的相应方法，在方法中返回第一步创建的动画管理器对象。</li>
</ul>


<!--more-->


<h2>准备工作</h2>

<p>下载示例程序，地址在<a href="https://www.dropbox.com/s/4p6kk0g3qua1kvt/CustomTransitionsStarter.zip?dl=0">这里</a>。（译注：原文地址需要FQ访问，本人已转存到GitHub上，点击<a href="https://github.com/WXGBridgeQ/CustomTransitions">这里</a>。）</p>

<p>示例程序如下图所示，点击导航栏上的Action按钮会modal出一个目标控制器，点击Dismiss按钮会返回来源控制器，只不过现在使用的是系统默认的modal动画，接下来我们就来实现自定义转场动画。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid01.gif" alt="" /></p>

<h2>创建动画管理器</h2>

<p>创建一个类名称为CustomPresentAnimationController，继承自NSObject并遵守UIViewControllerAnimatedTransitioning协议。这个协议有两个必须实现的方法，我们的实现代码如下：</p>

<pre><code class="objc">func transitionDuration(transitionContext: UIViewControllerContextTransitioning) -&gt; NSTimeInterval {
    return 2.5
}

func animateTransition(transitionContext: UIViewControllerContextTransitioning) {

    let fromViewController = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!
    let toViewController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!
    let finalFrameForVC = transitionContext.finalFrameForViewController(toViewController)
    let containerView = transitionContext.containerView()
    let bounds = UIScreen.mainScreen().bounds
    toViewController.view.frame = CGRectOffset(finalFrameForVC, 0, bounds.size.height)
    containerView.addSubview(toViewController.view)

    UIView.animateWithDuration(transitionDuration(transitionContext), delay: 0.0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.0, options: .CurveLinear, animations: {
        fromViewController.view.alpha = 0.5
        toViewController.view.frame = finalFrameForVC
        }, completion: {
            finished in
            transitionContext.completeTransition(true)
            fromViewController.view.alpha = 1.0
    })
}
</code></pre>

<p>第一个方法很简单，设定动画执行时间。第二个方法则用来编写我们自定义的动画代码，在这个方法中我们可以利用transitionContext（转场上下文）来获得我们将来的来源控制器、目标控制器、动画完成后的最终frame，还可以获得用来管理来源或目标视图的容器视图。</p>

<p>然后我们将目标视图调整到屏幕下方并将其添加到容器视图内。接下来在动画执行的闭包内，将目标视图的位置变为最终位置，并将来源视图的透明度降为0.5，使其在目标视图进入的过程中产生一个淡出的效果。在动画完成的闭包内，我们告知transitionContext动画已完成，并将来源视图的透明度改回1.0。</p>

<h2>设置转场动画代理</h2>

<p>接下来我们需要为目标控制器设置转场动画代理，这里我们指定来源控制器作为我们的代理。在ItemsTableViewController中，让其遵守UIViewControllerTransitioningDelegate协议，在storyboard中找到我们modal的segue，设置它的Identifier为showAction。然后在ItemsTableViewController中添加如下代码：</p>

<pre><code>let customPresentAnimationController = CustomPresentAnimationController()

override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {

    if segue.identifier == "showAction" {
        let toViewController = segue.destinationViewController as UIViewController
        toViewController.transitioningDelegate = self
    }
}

func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
    return customPresentAnimationController
}
</code></pre>

<p>我们创建了一个动画管理器对象，设置目标控制器的转场代理为来源控制器，然后实现代理协议中的animationControllerForPresentedController方法，该方法用于指定modal过程中展示视图的动画，在该方法中返回我们自定义的动画管理器对象。</p>

<p>运行我们的程序，效果如下图所示：</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid02.gif" alt="" /></p>

<p>跟系统默认modal效果差不多，不过带有弹簧效果。如果你希望有不同的效果，你可以对下面这句代码进行修改。</p>

<pre><code>toViewController.view.frame = CGRectOffset(finalFrameForVC, 0, bounds.size.height)
</code></pre>

<p>比如将其改为如下代码：</p>

<pre><code>toViewController.view.frame = CGRectOffset(finalFrameForVC, 0, -bounds.size.height)
</code></pre>

<p>再次运行程序，我们的modal动画就变为从上往下了。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid03.gif" alt="" /></p>

<h2>自定义modal过程中退出视图的动画</h2>

<p>我们的程序现在点击Dismiss退出目标控制器时，仍然是系统默认的动画，接下来实现这个自定义动画。</p>

<p>步骤同前面基本一样，创建一个叫做CustomDismissAnimationController的动画管理器，实现如下代理方法：</p>

<pre><code>func transitionDuration(transitionContext: UIViewControllerContextTransitioning) -&gt; NSTimeInterval {
    return 2
}

func animateTransition(transitionContext: UIViewControllerContextTransitioning) {
    let fromViewController = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!
    let toViewController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!
    let finalFrameForVC = transitionContext.finalFrameForViewController(toViewController)
    let containerView = transitionContext.containerView()
    toViewController.view.frame = finalFrameForVC
    toViewController.view.alpha = 0.5
    containerView.addSubview(toViewController.view)
    containerView.sendSubviewToBack(toViewController.view)

    UIView.animateWithDuration(transitionDuration(transitionContext), animations: {
        fromViewController.view.frame = CGRectInset(fromViewController.view.frame, fromViewController.view.frame.size.width / 2, fromViewController.view.frame.size.height / 2)
        toViewController.view.alpha = 1.0
    }, completion: {
        finished in
        transitionContext.completeTransition(true)
    })
}
</code></pre>

<p>这次我们使用一个新的动画方式，让来源视图从中心点开始逐渐变小直到消失。首先我们将目标控制器设置为最终位置，透明度为0.5，并将其添加到容器视图的底层中使其开始时不可见。在动画执行过程中，来源视图逐渐变小，露出底层的目标视图，并将目标视图透明度过渡到1.0。</p>

<p>接下来在ItemsTableViewController中添加如下代码：</p>

<pre><code>let customDismissAnimationController = CustomDismissAnimationController()

func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
    return customDismissAnimationController
}
</code></pre>

<p>animationControllerForDismissedController这个代理方法指定了modal过程中退出视图的动画。运行程序，你会发现我们的动画有点小Bug。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid05.gif" alt="" /></p>

<p>我们可以看到，白色的背景视图确实如我们所愿从中心点逐渐缩小，但是图片视图的大小却保持不变，这是因为改变来源视图的时候，它的子控件的大小并不会跟着发生改变，我们可以通过视图快照的技术来解决这一问题。</p>

<p>将animateTransition方法的实现修改为如下代码：</p>

<pre><code>func animateTransition(transitionContext: UIViewControllerContextTransitioning) {
    let fromViewController = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!
    let toViewController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!
    let finalFrameForVC = transitionContext.finalFrameForViewController(toViewController)
    let containerView = transitionContext.containerView()
    toViewController.view.frame = finalFrameForVC
    toViewController.view.alpha = 0.5
    containerView.addSubview(toViewController.view)
    containerView.sendSubviewToBack(toViewController.view)

    let snapshotView = fromViewController.view.snapshotViewAfterScreenUpdates(false)
    snapshotView.frame = fromViewController.view.frame
    containerView.addSubview(snapshotView)

    fromViewController.view.removeFromSuperview()

    UIView.animateWithDuration(transitionDuration(transitionContext), animations: {
        snapshotView.frame = CGRectInset(fromViewController.view.frame, fromViewController.view.frame.size.width / 2, fromViewController.view.frame.size.height / 2)
        toViewController.view.alpha = 1.0
    }, completion: {
        finished in
        snapshotView.removeFromSuperview()
        transitionContext.completeTransition(true)
    })  
}
</code></pre>

<p>我们给来源视图生成了一个快照，将它添加到容器视图中利用它来做动画，并将来源视图从父控件中移除。再次运行程序，我们的动画效果就正常了。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid06.gif" alt="" /></p>

<h2>导航控制器的转场动画</h2>

<p>在UITabBarController和UINavigationController的管理下，你无需为每个目标控制器都设置转场代理，可以直接设置UITabBarControllerDelegate或UINavigationControllerDelegate即可。</p>

<p>接下来我们演示如何为导航控制器设置自定义转场动画。首先，仍然是创建一个动画管理器类叫做CustomNavigationAnimationController，然后实现UIViewControllerAnimatedTransitioning协议的方法。这里的动画代码采用的是一个开源的三维旋转动画，读者可以到<a href="https://github.com/andresbrun/ABCustomUINavigationController#cube">这里</a>自行研究。</p>

<pre><code>var reverse: Bool = false

func transitionDuration(transitionContext: UIViewControllerContextTransitioning) -&gt; NSTimeInterval {
    return 1.5
}

func animateTransition(transitionContext: UIViewControllerContextTransitioning) {
    let containerView = transitionContext.containerView()
    let toViewController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!
    let fromViewController = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!
    let toView = toViewController.view
    let fromView = fromViewController.view
    let direction: CGFloat = reverse ? -1 : 1
    let const: CGFloat = -0.005

    toView.layer.anchorPoint = CGPointMake(direction == 1 ? 0 : 1, 0.5)
    fromView.layer.anchorPoint = CGPointMake(direction == 1 ? 1 : 0, 0.5)

    var viewFromTransform: CATransform3D = CATransform3DMakeRotation(direction * CGFloat(M_PI_2), 0.0, 1.0, 0.0)
    var viewToTransform: CATransform3D = CATransform3DMakeRotation(-direction * CGFloat(M_PI_2), 0.0, 1.0, 0.0)
    viewFromTransform.m34 = const
    viewToTransform.m34 = const

    containerView.transform = CGAffineTransformMakeTranslation(direction * containerView.frame.size.width / 2.0, 0)
    toView.layer.transform = viewToTransform
    containerView.addSubview(toView)

    UIView.animateWithDuration(transitionDuration(transitionContext), animations: {
        containerView.transform = CGAffineTransformMakeTranslation(-direction * containerView.frame.size.width / 2.0, 0)
        fromView.layer.transform = viewFromTransform
        toView.layer.transform = CATransform3DIdentity
    }, completion: {
        finished in
        containerView.transform = CGAffineTransformIdentity
        fromView.layer.transform = CATransform3DIdentity
        toView.layer.transform = CATransform3DIdentity
        fromView.layer.anchorPoint = CGPointMake(0.5, 0.5)
        toView.layer.anchorPoint = CGPointMake(0.5, 0.5)

        if (transitionContext.transitionWasCancelled()) {
            toView.removeFromSuperview()
        } else {
            fromView.removeFromSuperview()
        }
        transitionContext.completeTransition(!transitionContext.transitionWasCancelled())
    })        
}
</code></pre>

<p>注意这里我们添加了一个reverse变量，用来指定转场动画的方向，这样我们可以将导航控制器push和pop过程的动画封装在一个动画管理器中。</p>

<p>在ItemsTableViewController中更改它的声明使其遵守UINavigationControllerDelegate协议，在viewDidLoad方法中设置代理为自己<code>navigationController?.delegate = self</code>，然后添加如下代码：</p>

<pre><code>let customNavigationAnimationController = CustomNavigationAnimationController()

func navigationController(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
    customNavigationAnimationController.reverse = operation == .Pop
    return customNavigationAnimationController
}
</code></pre>

<p>上面这个导航控制器的代理方法用于指定push或pop时的转场动画，其中operation参数可以用来判断转场的方向。运行程序，如下图所示：</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid07.gif" alt="" /></p>

<h2>导航控制器的手势交互</h2>

<p>我们知道苹果官方为导航控制器添加了一个默认的手势交互，就是在屏幕左侧向右滑动可以返回上一界面并带有pop动画，接下来我们为我们的自定义动画添加手势交互。</p>

<p>手势交互的管理器需要遵守的是UIViewControllerInteractiveTransitioning协议，该协议需要实现startInteractiveTransition方法指定开始交互，不过苹果官方为我们提供了另一个已经实现该协议的交互管理器类UIPercentDrivenInteractiveTransition，并提供以百分比的形式来控制交互过程的功能，比如控制交互的更新、取消、完成等，我们直接使用它来实现我们的交互控制。</p>

<p>创建一个类叫做CustomInteractionController并继承自UIPercentDrivenInteractiveTransition，添加如下代码：</p>

<pre><code>var navigationController: UINavigationController!
var shouldCompleteTransition = false
var transitionInProgress = false
var completionSeed: CGFloat {
    return 1 - percentComplete
}

func attachToViewController(viewController: UIViewController) {
    navigationController = viewController.navigationController
    setupGestureRecognizer(viewController.view)
}

private func setupGestureRecognizer(view: UIView) {
        view.addGestureRecognizer(UIPanGestureRecognizer(target: self, action: "handlePanGesture:"))
}

func handlePanGesture(gestureRecognizer: UIPanGestureRecognizer) {
    let viewTranslation = gestureRecognizer.translationInView(gestureRecognizer.view!.superview!)
    switch gestureRecognizer.state {
    case .Began:
        transitionInProgress = true
        navigationController.popViewControllerAnimated(true)
    case .Changed:
        var const = CGFloat(fminf(fmaxf(Float(viewTranslation.x / 200.0), 0.0), 1.0))
        shouldCompleteTransition = const &gt; 0.5
        updateInteractiveTransition(const)
    case .Cancelled, .Ended:
        transitionInProgress = false
        if !shouldCompleteTransition || gestureRecognizer.state == .Cancelled {
            cancelInteractiveTransition()
        } else {
            finishInteractiveTransition()
        }
    default:
        println("Swift switch must be exhaustive, thus the default")
    }
}
</code></pre>

<p>attachToViewController方法用于将来传入导航控制器的目标控制器，我们为目标控制器的整个view添加了滑动手势以便将来可以实现滑动返回的pop动画，在监听手势滑动的方法中，我们根据手势的状态做如下处理：</p>

<ul>
<li>开始滑动：设置transitionInProgress为true，并开始执行导航控制器的pop返回。</li>
<li>滑动过程中：更新交互过程的百分比，我们假设指定滑动200点即为交互完成。</li>
<li>取消或结束：设置transitionInProgress为false，如果交互过程执行50%以上则认为交互完成。</li>
</ul>


<p>接来下来到我们的ItemsTableViewController，添加如下代码：</p>

<pre><code>let customInteractionController = CustomInteractionController()
</code></pre>

<p>然后修改我们之前实现的导航控制器的代理方法如下：</p>

<pre><code>func navigationController(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
    if operation == .Push {
        customInteractionController.attachToViewController(toVC)
    }
    customNavigationAnimationController.reverse = operation == .Pop
    return customNavigationAnimationController
}
</code></pre>

<p>当我们push一个目标控制器时，就为该目标控制器设定交互控制。最后实现导航控制器代理中的另一个方法用于指定交互控制器，代码如下：</p>

<pre><code>func navigationController(navigationController: UINavigationController, interactionControllerForAnimationController animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? {
    return customInteractionController.transitionInProgress ? customInteractionController : nil
}
</code></pre>

<p>运行程序，如下图所示：</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid09.gif" alt="" /></p>

<p>完整的示例程序链接地址请点击<a href="https://github.com/appcoda/CustomViewTransitionDemo">这里</a>。</p>

<p>推荐阅读：</p>

<ul>
<li><a href="http://objccn.io/issue-12-3/">objc中国：自定义 ViewController 容器转场</a></li>
<li><a href="http://onevcat.com/2013/10/vc-transition-in-ios7/">喵神的好文：WWDC 2013 Session笔记 - iOS7中的ViewController切换</a></li>
</ul>


<h2>实现下拉菜单的小Demo</h2>

<p>Demo实现效果如下图所示，下载完整的Demo代码请点击<a href="https://www.dropbox.com/s/yxxuidy9veqiva8/SlideMenu.zip?dl=0">这里</a>。（译注：原文地址需要FQ访问，本人已转存到GitHub上，点击<a href="https://github.com/WXGBridgeQ/CustomTransitions">这里</a>。）</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/07/slide-down-menu-optimize.gif" alt="" /></p>

<p>实现过程同我们前面讲的自定义转场动画过程一样，首先创建一个动画管理器类MenuTransitionManager，然后设置目标控制器的转场代理，这次我们使用动画管理器对象作为代理，所以MenuTransitionManager既遵守了UIViewControllerAnimatedTransitioning协议，也遵守了UIViewControllerTransitioningDelegate协议。动画的执行代码比较简单，只是通过改变transform控制来源和目标视图的上下移动，目标视图我们仍然使用了快照技术。</p>

<p>我们还为来源视图的快照添加了一个点击的手势，这样在显示下拉菜单后，除了点击相应的菜单选项，点击下部的快照也可以返回到主页视图。只不过点击手势的处理我们使用了代理设计模式，而点击手势的添加我们使用了Swift的属性观察器语法，读者可以自行研究学习。</p>

<p>最后，希望大家学的愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building Adaptive UI 搭建自适应界面 | AppCoda翻译系列]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/06/30/adaptive-layout-tutorial/"/>
    <updated>2015-06-30T15:52:14+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/06/30/adaptive-layout-tutorial</id>
    <content type="html"><![CDATA[<p>（本文翻译自AppCoda创建者Simon Ng出版的书籍《iOS开发中级教程》，详见：<a href="http://www.appcoda.com/intermediate-swift-programming-book/">Intermediate iOS Programming with Swift</a>）</p>

<p>起初，iPhone只有一种3.5英寸的屏幕，那时的软件界面很容易搭建，开发者只需要处理两种不同方向上的界面展示（水平和竖直方向）。之后，苹果发布了9.7英寸屏幕的iPad，这个时候的开发者必须为他们的应用创建两个不同的界面（比如创建两个storyboard或者xib文件），一个用来搭建iPhone版的界面，另一个用来搭建iPad版的。</p>

<p>好日子一去不复返！从2014年开始，苹果公司的iPhone和iPad产品线变化很大。随着iPhone 6和iPhone 6 Plus的发布，现在的应用需要适配多种不同屏幕尺寸的设备，主要有如下几种：</p>

<ul>
<li>iPhone 4/4s（3.5英寸）</li>
<li>iPhone 5/5c/5s（4英寸）</li>
<li>iPhone 6（4.7英寸）</li>
<li>iPhone 6 Plus（5.5英寸）</li>
<li>iPad / iPad 2 / iPad Air / iPad Air 2（9.7英寸）</li>
<li>iPad mini / iPad mini 2 / iPad mini 3（7.9英寸）</li>
</ul>


<!--more-->


<p>对开发者来说，创建一个能够适配多种屏幕尺寸和方向的通用型界面是一个非常大的挑战。那么，我们如何来创建一个像素不被拉伸、界面完美的应用呢？</p>

<p>在iOS 8中，苹果推出了一种新技术叫做<code>Adaptive User Interfaces (自适应界面)</code>，它能够支持不同尺寸、不同方向屏幕的适配，使用这种技术，我们的应用就可以适配以上多种iPhone和iPad设备了。</p>

<p>实现自适应界面，需要了解一个新概念——<code>Adaptive Layout (自适应布局)</code>。在Xcode 6中，开发者可以通过使用<em>a universal storyboard</em>来搭建能够适配所有设备的自适应界面。现在，你可以只使用一个storyboard文件来布局你所有的视图控件，包括iPhone和iPad版本。</p>

<p>为了实现自适应布局，苹果在iOS 8中推出了<code>Size Classes</code>技术，它是实现自适应布局中最重要的一步。<code>Size Classes</code>是对不同尺寸、不同方向的设备的一种抽象，将<code>Size Classes</code>和<code>Auto Layout (自动布局)</code>技术结合起来使用，就能够搭建出自适应界面。在iOS 8中，实现自适应布局需要如下几个步骤：</p>

<ol>
<li>先使用自动布局来搭建你的界面，自动布局已经能够处理大多数尺寸和方向的适配任务。</li>
<li>针对不同的<em>size classes</em>添加特定的布局约束。比如说，当设备横屏时增加两个标签之间的间距。</li>
</ol>


<p>在本文中，我将介绍如何使用各种自适应界面技术来创建一个通用型的应用，它可以适配各种不同尺寸和方向的设备。</p>

<h2>自适应界面示例</h2>

<p>本次示例工程不需要编写代码，我们主要使用storyboard来布局我们的视图组件，并学习如何使用自动布局和<em>Size Classes</em>技术来实现自适应界面。通过本文的学习，你将会构建一个具有单一视图控制器的应用，该应用可以适配任何不同尺寸和方向的设备。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui01.png" alt="" /></p>

<h2>创建Xcode工程</h2>

<p>首先，启动Xcode，创建一个<code>Single View Application</code>的项目，项目名称填入<code>AdaptiveUIDemo</code>，并确保<code>Devices</code>选项选择的是<code>Universal</code>。</p>

<p>一旦创建完项目，打开<code>Main.storyboard</code>文件，你会看见一个600×600尺寸的方形控制器视图，因为使用了<code>Size Classes</code>功能，控制器的视图表示的是一个通用的设备，而不是像以前那样表示的是一个具体的设备（例如4英寸的iPhone）。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui02.png" alt="" /></p>

<p>你可以使用自动布局对视图组件（比如标签）进行约束，同以前旧版本的Xcode或者关闭了<code>Size Classes</code>功能的项目一样。</p>

<p>接下来，下载图片资源并将其添加到项目的<code>images.xcassets</code>里面。链接地址点击<a href="https://www.dropbox.com/s/1rnlpib0dtttom8/adaptiveui-images.zip?dl=0">这里</a>。（译注：原文资源文件地址需要FQ访问，本人已转存到这里：<a href="http://7xk1wz.com1.z0.glb.clouddn.com/tshirt.jpg">图片1</a>、<a href="http://7xk1wz.com1.z0.glb.clouddn.com/tshirt@2x.jpg">图片2</a>、<a href="http://7xk1wz.com1.z0.glb.clouddn.com/tshirt@3x.jpg">图片3</a>）</p>

<p>接下来，回到storyboard文件，往控制器中拖入一个<code>UIImageView</code>，设置它的宽度为600、高度为390，在属性选项卡中，设置image为<code>tshirt</code>，Mode选择<code>Aspect Fill</code>。在本文接下来的内容中，我将把这个<code>UIImageView</code>叫做产品图片视图。</p>

<p>然后，再往控制器中拖入一个<code>UIView</code>，放在产品图片视图的下面，设置它的宽度为600、高度为210。这个<code>UIView</code>将作为一个容器，用来装我们的其他视图控件（比如标签），把一些相关联的组件包装在一个父视图内，将更有利于我们对其进行布局。在本文接下来的内容中，我将把这个<code>UIView</code>叫做产品简介视图。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui03.png" alt="" /></p>

<p>接下来，往产品简介视图中拖入一个<code>UILable</code>，将其文本内容设置为<em>PSD T-Shirt Mockup Template</em>，将字体设置为<em>Avenir Next</em>，字体大小设置为32，在尺寸选项卡中，将X改为22、Y改为15、宽度改为556、高度改为44。在本文接下来的内容中，我将把这个<code>UILabel</code>叫做标题标签。</p>

<p>再拖入一个<code>UILabel</code>放在标题标签的下面，将其文本内容设置为<em>This is a free psd T-shirt mockup provided by pixeden.com. The PSD comes with a plain simple tee-shirt mockup template. You can edit the t-shirt color and use the smart layer to apply your designs. The high-resolution makes it easy to frame specific details with close-ups.</em>，同样将字体设置为<em>Avenir Next</em>，字体大小设为18，<em>Lines</em>设为0。在尺寸选项卡中，将X改为22、Y改为58、宽度改为556、高度改为123。在本文接下来的内容中，我将把这个<code>UILabel</code>叫做产品描述标签。</p>

<p>要注意这两个标签是放在产品简介视图里面的，你可以打开大纲视图来确认它们的层级关系是否正确。如果你做的正确，你的界面应该和下图所示一样。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui04.png" alt="" /></p>

<p>如果你的界面跟上图在位置上不完全一致也没关系，因为接下来要对这些控件添加约束进行自动布局。</p>

<p>现在先让我们来看一下我们的界面在不同的设备上表现如何。在Xcode 6中，你可以不通过启动模拟器运行程序就能看到你的界面如何展示。最新版本的Xcode提供了一个预览功能，可以使开发者快速方便地查看界面在不同尺寸设备上的样子。</p>

<p>如下图所示操作，点击助手弹出菜单选择预览，然后按住<em>shift</em>和<em>option</em>键点击<code>Main.storyboard</code>。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui05.png" alt="" /></p>

<p>你可以选择在哪个区域显示预览窗口。双击<em>main</em>旁边的加号按钮，Xcode会自动打开助手编辑视图并将应用界面的预览显示出来。默认显示出的是4英寸iPhone上应用界面的样子，你可以点击左下角的加号按钮来添加不同尺寸的设备，从而来查看应用界面在不同屏幕尺寸上的显示。如果你添加了所有尺寸的设备，包括iPad设备，你的屏幕现在应该跟下图所示一样。你会发现，我们现在的界面不能很好的适应所有的设备，这是因为我们还没有使用自动布局来给控件添加约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui06.png" alt="" /></p>

<h2>添加自动布局约束</h2>

<p>现在我们来为视图组件添加布局约束。首先从我们的产品图片视图开始，有些开发者对自动布局感到恐惧，我的习惯是先用普通的语言将约束描述一遍，以我们的产品图片视图为例，我认为对它的约束应该是下面这个样子：</p>

<ul>
<li>在产品图片视图和主视图之间，它们的上边、左边和右边的间距应该为0。</li>
<li>产品图片视图大约占主视图的65%~70%左右</li>
<li>产品图片视图和它下边的产品简介视图之间的间距也应该为0。</li>
</ul>


<p>把这些描述转换成自动布局的约束，看上去应该如下所示：</p>

<ul>
<li>约束产品图片视图的上边、左边和右边的间距，值设为0。</li>
<li>给产品图片视图增加一个相对于主视图的高度约束，将相乘的系数设为0.65。</li>
<li>添加产品图片视图和产品简介视图之间的间距约束，值设为0。</li>
</ul>


<p>现在我们开始设置这些约束，选择产品图片视图，点击自动布局菜单中的<em>Pin</em>按钮，选中上边、左边、右边的约束并设置为0，注意要确保<code>Constrain to margin</code>没有被选中，然后点击下边的按钮添加三个约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui07.png" alt="" /></p>

<p>接下来，打开左侧的大纲视图，按住<em>Control</em>键从产品图片视图拖到主视图，在弹出的菜单中选择等高约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui08.png" alt="" /></p>

<p>添加完等高约束后，该约束就会出现在大纲视图上。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui09.png" alt="" /></p>

<p>选中该约束，点击右侧的尺寸选项卡，在这里你可以对该约束进行自定义的设置。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui10.png" alt="" /></p>

<p>在设置之前，先查看一下<code>first item</code>中是否是<em>tshirt.Height</em>、<code>second item</code>中是否是<em>SuperView.Height</em>，如果不是，可以点击下拉菜单然后选择<em>Reverse First and Second item</em>。</p>

<p>默认情况下，两个高度值之间的相乘系数是1，代表着产品图片视图占据了主视图的100%，我们希望产品图片视图只是占据主视图的65%，所以将相乘的系数改为0.65。</p>

<p>接下来，选择产品简介视图，点击<em>Pin</em>按钮，选中左边、右边和下边的约束，设置为0。同样要确保<code>Constrain to margin</code>选项没有被选中，然后点击下边按钮添加三个约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui11.png" alt="" /></p>

<p>接下来，我们要为产品图片视图和产品简介视图添加间距约束。在大纲视图中，按住<em>Control</em>键从产品图片视图拖到产品简介视图。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui12.png" alt="" /></p>

<p>在弹出的菜单中选择<em>竖向间距</em>约束，这样我们就添加了产品图片视图的底部和产品简介视图的顶部之间的间距约束。</p>

<p>现在再预览一下我们的界面，你会发现在不同尺寸的设备上它看上去稍微好一些了，但是我们还可以做很多事情来让它变得更好。</p>

<p>现在，我们来为产品简介视图中的两个标签设置约束。</p>

<p>先选择标题标签，就是看上去字体更大的那个，点击自动布局的<em>Pin</em>按钮，设置它上边约束15、左边约束22、右边约束22，记住确保<code>Constrain to margin</code>选项没有被选中，然后点击下边的按钮添加三个约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui13.png" alt="" /></p>

<p>接下来，选择产品描述标签，用同样的办法设置它的下边约束29、左边约束22、右边约束22。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui14.png" alt="" /></p>

<p>最后，给两个标签添加间距约束，按住<em>Control</em>键从标题标签拖到产品描述标签，同样，在弹出的菜单中选择<em>竖向间距</em>约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui15.png" alt="" /></p>

<p>当你添加完这个约束后，你会在storyboard上发现很多黄色和红色的线，这表示我们的布局现在存在问题，当约束不明确或有冲突时就会产生布局问题。</p>

<p>要解决布局问题，可以点击大纲视图中的红色箭头，这样会列出现在存在所有的布局问题。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui16.png" alt="" /></p>

<p>Xcode非常智能可以帮助我们很容易地解决布局问题，通过点击红色指示器按钮，就会弹出多种可能的解决办法，我们选择<em>Change Priority</em>来解决我们之前的布局问题。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui17.png" alt="" /></p>

<p>非常棒！我们已经完成了所有视图控件的自动布局，现在重新在预览视图中查看我们的界面在不同尺寸设备上的展示。</p>

<p>界面看上去比之前要好多了，产品图片已经能正确的显示。然而，我们的界面还有以下几处问题需要解决：</p>

<ul>
<li>产品描述标签在iPad上被竖向居中显示了</li>
<li>标题标签不能被完整地显示，尤其是在iPhone设备上</li>
<li>产品描述标签在iPhone上也只是部分显示</li>
</ul>


<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui18.png" alt="" /></p>

<p>我们先来解决第一条问题，很明显，问题应该出在我们为产品描述标签添加的约束上。你可以在尺寸选项卡里面查看已经添加的约束。选择产品描述标签，然后选择尺寸选项卡。</p>

<p>你会发现如下图所示的一系列约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui19.png" alt="" /></p>

<p>我们给产品描述标签添加了四个约束，很明显，我们的问题应该与上边和下边的间距约束有关。</p>

<p>在自动布局中，每一个约束都有一个优先级的概念，高优先级的约束会比低优先级的约束优先被执行。所有新建的约束其优先级都会被设为一个相同的值（值为1000），意味着所有约束都同等重要、都需要被执行。我们产品描述标签的上边和下边约束的优先级相同，但是看上去好像下边的约束更胜一筹，导致我们标题标签和产品描述标签中间出现了一个很大的间距。</p>

<p>要解决这个问题，应该把产品描述标签的下边间距约束的优先级降低。点击下边间距约束上的<em>Edit</em>按钮，将<em>priority</em>的值改为250。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui20.png" alt="" /></p>

<p>这样完成之后，我们的第一条界面问题就解决了。</p>

<h2>Size Classes</h2>

<p>不要忘了，我们之前提到过自适应界面技术需要两个步骤，到目前为止我们只是完成了界面的自动布局，自动布局能够满足大多数情况下的界面适配，接下来的第二步我们将使用<code>Size Classes</code>技术让我们的界面看上去更加完美。</p>

<p>一个<code>size class</code>代表了一种或多种屏幕尺寸的抽象，包括竖直方向（高度）和水平方向（宽度）的尺寸。在iOS 8中有两种类型的<code>size class</code>：<em>regular</em>(整齐的)和<em>compact</em>（紧凑的）。<em>regular</em>类型的<code>size class</code>表示一个比较大的屏幕空间，<em>compact</em>类型的<code>size class</code>则表示一个比较小的屏幕空间。</p>

<p>使用<code>size classes</code>来抽象地描述屏幕的尺寸，会有以下四种结果：<code>Regular width-Regular Height</code>、<code>Regular width-Compact Height</code>、<code>Compact width-Regular Height</code>和<code>Compact width-Compact Height</code>。</p>

<p>下图中的表格展示了不同iOS设备对应的<code>size classes</code>模型。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui21.png" alt="" /></p>

<p>为了描述真实的显示环境，你必须指定水平和竖直两个方向上的<code>size class</code>类型，以iPad为例，你应该指定它的<code>size class</code>为<code>Regular width-Regular Height</code>。</p>

<p>在自动布局的基础上，你可以为不同的<code>size classes</code>指定特定的布局约束，比如说，你可以为<code>size class</code>设为<code>compact height-regular width</code>的屏幕上的标签指定特定的字体大小，你也可以专门为<code>regular-regular</code>尺寸的屏幕改变一个按钮的位置。</p>

<p>需要注意的是，所有iPhone设备的竖向屏幕的<code>size class</code>都为<code>compact width-regular height</code>，这意味着你的界面在iPhone 4s和iPhone 6上竖屏展示的样子是几乎一样的。而对于iPhone 6 Plus的横屏来说，它的<code>size class</code>应该是<code>regular width-compact height</code>，这表示你的界面与在iPhone 4/5/6上的展示是完全不一样的。</p>

<p>对<code>Size Classes</code>的基本概念有过了解之后，我们接下来看看如何解决我们应用界面剩下的两个问题：</p>

<ul>
<li>标题标签不能被完整地显示，尤其是在iPhone设备上</li>
<li>产品描述标签在iPhone上也只是部分显示</li>
</ul>


<h2>使用Size Classes自定义字体大小</h2>

<p>我们想让标题标签和描述标签能在iPhone上完美显示，问题是现在字体的大小对于iPad来说很合适，但是对于iPhone来说它太大了。</p>

<p>使用<code>Size Classes</code>技术，你可以为不同尺寸的屏幕指定特定的字体大小。接下来，我们想要改变所有iPhone的竖屏界面内的字体大小，在<code>size classes</code>的表格中我们可以看出，它对应的<code>size class</code>应为<code>compact width-regular height</code>。</p>

<p>想要为不同尺寸设置不同的字体大小，首先在storyboard中选中我们的标题标签，在属性选项卡中<em>Font</em>选项左边，你会发现有一个加号按钮。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui22.png" alt="" /></p>

<p>点击加号按钮然后依次选择<code>compact width-regular height</code>，</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui23.png" alt="" /></p>

<p>然后你会发现新添加了一条<em>Font</em>选项专门用来设置你所指定的<code>size class</code>，保持原始的<em>Font</em>选项不变，我们只需将新的<em>Font</em>选项内的字体大小改为20。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui24.png" alt="" /></p>

<p>这样做的意思是通知系统，在所有iPhone设备的竖屏显示时，使用更小一点的字体大小，而在iPad上显示时，仍然使用我们早期设置的大小。接下来选择产品描述标签，同样更改它在<code>compact width-regular height</code>下的字体大小为13。查看预览视图，我们的文字已经能够完美地展示在不同设备上了。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui25.png" alt="" /></p>

<h2>使用Size Classes自定义界面的设计</h2>

<p>现在我们的界面已经适配所有的竖屏尺寸了，那么在横屏显示时，我们的界面又是如何展示的呢？</p>

<p>在预览窗口内，点击设备下部的旋转按钮（比如点击4英寸的iPhone）。很明显，我们的界面在iPhone的横屏上并不能很好的展示。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui26.png" alt="" /></p>

<p>你可能会想到我们可以为横屏尺寸的屏幕设置更小的字体，就跟我们之前做的一样，我并不打算这么去做。</p>

<p>我将重新设计横屏界面的布局来代替之前的设计，目的是为了更好的利用横屏模式下更宽的尺寸，这才是<code>Size Classes</code>技术能力的体现。</p>

<p>对于横屏界面来说，将产品图片视图和产品简介视图并排显示效果可能更好，并且每一个视图占据主视图的50%，我们的界面应该看上去像下图这样。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui27.png" alt="" /></p>

<p>到目前为止，我们并没有介绍<code>Size Classes</code>在视图布局上如何应用，我们之前设计的界面一直是在<code>wAny hAny</code>的<code>size class</code>下进行的。</p>

<p>现在，点击storyboard下方的<code>wAny hAny</code>按钮，在这里我们能够通过选择表格大小来指定不同的<code>size class</code>。我们想要更改iPhone设备横屏下的界面布局，所以我们选择<code>Any Width-Compact Height</code>，它代表了所有iPhone设备的横屏显示（包括iPhone 6 Plus）。</p>

<p>在表格中移动鼠标，选择<code>Any Width-Compact Height</code>的<code>size class</code>。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui28.png" alt="" /></p>

<p>当你选择特定的<code>size class</code>之后，控制器视图的尺寸也会发生相应的改变，在storyboard底部会标示出你当前所指定的<code>size class</code>为<em>wAny hCompact</em>，接下来你做的所有布局，都只会针对当前的<code>size class</code>，而不会影响到其他尺寸，这就是在Xcode中如何使用一个storyboard文件来展示多种界面布局的原理。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui29.png" alt="" /></p>

<p>好，接下来我们开始设计我们的界面。</p>

<p>当前的界面会将我们之前添加的布局约束保留下来（<code>size class</code>为<em>wAny hAny</em>的时候），因为我们接下来想要重新去布局我们的界面，所以我们应该先把之前的约束全部清空。</p>

<p>在大纲视图中选择主视图，然后点击自动布局菜单中的<em>Issues</em>按钮，然后选择<em>All Views</em>下面的<em>Clear Constraints</em>选项。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui30.png" alt="" /></p>

<p>这样会清空我们当前<code>size class</code>下的所有布局约束，注意那些约束在<em>wAny hAny</em>下仍然有效，我们只是将<em>wAny hCompact</em>下的所有约束给清空了。</p>

<p>你可以打开大纲视图展开约束列表，你会发现所有约束都还在只是变成了灰色，意味着当前<code>size class</code>下它们不可用。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui31.png" alt="" /></p>

<p>如果你选中任意一个约束，然后打开尺寸选项卡，你会发现有两个<em>Installed</em>复选框，而且<em>wAny hCompact</em>下的<em>Installed</em>没有被选中，而通用布局下的<em>Installed</em>被选中了，这验证了我们只是将当前<code>size class</code>下的约束给清除了，并没有影响其他尺寸下的布局约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui32.png" alt="" /></p>

<p>接下来，我们开始布局我们的新界面，让产品图片视图和产品简介视图并排显示在一行。</p>

<p>首先，选择产品图片视图，在尺寸选项卡下，设置X为0、Y为0、宽度为300、高度为400，然后选择产品简介视图，设置它的尺寸X为300、Y为0、宽度为300、高度为400，界面的效果应该像下图一样。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui33.png" alt="" /></p>

<p>接下来，选择标题标签，设置它的尺寸X为22、Y为15、宽度为256、高度为70，标题文字的字体太大了，所以我们要为当前<code>size class</code>下的字体设置特定的大小，在属性选项卡中，点击<em>Font</em>旁边的加号按钮，选择<em>Any Width | Compact Height (current)</em>选项。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui34.png" alt="" /></p>

<p>这样就新建了一个对当前<code>size class</code>下的字体设置，把它的大小改为25。现在我们的标题标签只能显示在一行里，将<em>Lines</em>属性从1改为0，标题标签会自动判断自己应该显示几行。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui35.png" alt="" /></p>

<p>选择产品描述标签，设置它的尺寸X为22、Y为85、宽度为256、高度为250，现在我们的界面应该如下图所示。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui36.png" alt="" /></p>

<p>因为我们之前已经把所有约束清空了，所以接下来我们必须为当前<code>size class</code>下的界面添加自动布局约束。</p>

<p>选择产品图片视图，点击<em>Pin</em>按钮，添加上边、左边、下边间距约束为0，记住不要选中<code>Constrain to margins</code>，然后点击添加三个约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui37.png" alt="" /></p>

<p>接下来选择产品简介视图，同样设置它的上边、右边、下边间距约束为0。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui38.png" alt="" /></p>

<p>在大纲视图内，按住<em>Control</em>键从主视图拖到产品图片视图，选择等宽约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui39.png" alt="" /></p>

<p>这条约束是要用来表示产品图片视图占据主视图的一半，就像之前我们将等高约束相乘系数改为0.65一样，这里我们把等宽约束的相乘系数改为0.5，这样产品图片视图就只占据主视图的50%了。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui40.png" alt="" /></p>

<p>接下来我们为产品图片视图和产品简介视图添加间距约束。在大纲视图中，按住<em>Control</em>键从产品图片视图拖到产品简介视图，在弹出的菜单中选择<em>竖向间距</em>约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui41.png" alt="" /></p>

<p>好了，现在我们搞定产品图片视图和产品简介视图的所有约束了，剩下的就是为两个标签添加约束了。</p>

<p>首先选择标题标签，设置它的约束为上边15、左边22、右边22，记住不要选中<code>Constrain to margins</code>选项。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui42.png" alt="" /></p>

<p>按住<em>Control</em>键从标题标签拖到产品描述标签，在弹出的菜单中选择<em>竖向间距</em>约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui43.png" alt="" /></p>

<p>选择产品描述标签，设置它的约束为左边22、右边22，记住不要选中<code>Constrain to margins</code>选项。</p>

<p>storyboard会提示我们现在的约束有些问题。在大纲视图中点击右上角的黄色箭头，然后点击黄色指示器按钮，然后选择<em>Update frame</em>选项来解决我们所有的布局问题。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui44.png" alt="" /></p>

<p>非常棒！现在再去预览视图中查看我们应用的界面在横屏下的显示，如下图所示。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui45.png" alt="" /></p>

<p>我们的界面看上去非常精美，对吧？然而在3.5和4英寸的iPhone上，产品描述标签的显示还有一些小问题。要解决这个问题，你需要新建一个针对这种情况下的<code>size class</code>的字体设置选项，我将这一步留给你们自行练习解决。</p>

<p>接下来，点击运行按钮使用模拟器运行我们的程序，当你将设备从竖屏旋转到横屏时，你会发现我们的界面在发生变化的过程中还带有非常平滑的转场动画。</p>

<h2>使用Size Classes自定义约束</h2>

<p>希望你现在已经理解如何使用<code>Size Classes</code>技术来自定义字体和自定义界面设计，除此之外，使用<code>Size Classes</code>技术还可以自定义约束。</p>

<p>如果我想让我们的界面在iPhone 6 Plus下展示成下图的样子，却不改变它在其他iPhone设备上的展示，那么我该如何去做呢？</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui46.png" alt="" /></p>

<p>从图中我们可以看到，标题标签和产品描述标签被移到了右下方，很明显，我们应该自定义标题标签同它的父视图（产品简介视图）之间的上边间距，让我们来看看应该如何去做。</p>

<p>iPhone 6 Plus横屏的<code>size class</code>应该为<code>Regular width-Compact Height</code>，在storyboard下方的<em>Size Classes</em>表格选项中选择<code>Regular width-Compact Height</code>并确认。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui47.png" alt="" /></p>

<p>在大纲视图中，找到标题标签同它父控件之间的竖向间距约束。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui48.png" alt="" /></p>

<p>在尺寸选项卡中，你可以在<em>Constant</em>选项旁边看到一个加号按钮，<em>Constant</em>的值现在被设置为15，我们希望在当前<code>size class</code>下增大这个间距，所以点击加号按钮，选择<code>Regular Width | Compact Height (current)</code>选项。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui49.png" alt="" /></p>

<p>在新建的<em>wR hC</em>选项中，将间距值设为230。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui50.png" alt="" /></p>

<p>如果你的大纲视图中显示存在布局约束问题，你可以点击箭头，然后根据Xcode的建议来解决约束问题。</p>

<p>再次在预览视图中查看我们的界面，你会发现5.5英寸的iPhone界面改变了，而其他iPhone设备上的界面并没有变化。</p>

<h2>总结</h2>

<p>在iOS 8和Xcode 6中，苹果为开发者提供了非常强大的工具来搭建自适应界面。在本文中，我们介绍了<code>Size Classes</code>技术和相关概念，并展示了如何搭建一个自适应的界面。</p>

<p><img src="http://7xk1wz.com1.z0.glb.clouddn.com/adaptiveui51.png" alt="" /></p>

<p>自适应布局是iOS 8中一个非常重要的新特性，开发者只针对一种设备、一种屏幕尺寸去设计界面的日子不可能再有了，如果你正打算开发一款新的应用，确保你已经熟悉自动布局和<code>Size Classes</code>技术，从而让你的应用能够适配多种屏幕尺寸和方向，未来的应用界面肯定更需要自适应布局技术。</p>

<p>你可以在<a href="https://www.dropbox.com/s/j2dja7mck9rgfvd/AdaptiveUIDemo.zip?dl=0">这里</a>下载本教程的完整示例代码，供你学习和参考。（译注：原文资源文件地址需要FQ访问，本人已转存到GitHub上，详见<a href="https://github.com/WXGBridgeQ/AdaptiveUIDemo">这里</a>）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIScrollView新手教程 | AppCoda翻译系列]]></title>
    <link href="http://wxgbridgeq.github.io/blog/2015/06/19/uiscrollview-tutorial/"/>
    <updated>2015-06-19T10:08:23+08:00</updated>
    <id>http://wxgbridgeq.github.io/blog/2015/06/19/uiscrollview-tutorial</id>
    <content type="html"><![CDATA[<p>（本文翻译自AppCoda，详见：<a href="http://www.appcoda.com/uiscrollview-introduction/">原文链接：A Beginner’s Guide to UIScrollView</a>）</p>

<p>在iOS开发中，滚动视图（UIScrollView）通常用于显示内容尺寸大于屏幕尺寸的视图。滚动视图有以下两个主要作用：</p>

<ul>
<li><p>让用户可以通过拖拽手势来观看想看到的内容</p></li>
<li><p>让用户可以通过捏合手势来放大或缩小观看的内容</p></li>
</ul>


<p>在iOS应用中常见的表格视图（UITableView）就继承自滚动视图，并因此可以通过上下滚动来显示更多的内容。</p>

<p>在本篇教程中，我们将讨论滚动视图的诸多方面内容，主要包括：使用纯代码和可视化编程两种方式来创建一个滚动视图、实现滚动和缩放功能，以及如何嵌套使用滚动视图。</p>

<!--more-->


<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/uiscrollview-guide.jpg" alt="" /></p>

<p>继续阅读之前，请先下载本文示例代码所需的资源文件，详见：<a href="https://www.dropbox.com/s/qhdja7ixcfixu8e/UIScrollViewStarter.zip?dl=0">资源文件地址</a>。（译注：原文资源文件地址需要FQ访问，本人已转存到GitHub上，详见<a href="https://github.com/WXGBridgeQ/UIScrollViewStarter">这里</a>）</p>

<h2>使用纯代码方式创建UIScrollView</h2>

<p><code>UIScrollView</code>同其他视图一样，可以通过纯代码和可视化编程两种方式来创建。在创建之后，只需要少量额外设置就可以让<code>UIScrollView</code>获得基本的滚动功能。</p>

<p><code>UIScrollView</code>也和其他视图一样，应该被一个控制器管理或者添加到某个视图层级中。想要完成滚动功能还需要对<code>UIScrollView</code>进行以下两步设置：</p>

<ul>
<li><p>必须设置<code>UIScrollView</code>的<code>contentSize</code>属性，它提供了<code>UIScrollView</code>的内容的大小，也就是可以滚动的区域的大小。</p></li>
<li><p>必须为<code>UIScrollView</code>添加一个或多个用于显示和滚动的子视图，这些视图提供了<code>UIScrollView</code>显示的内容。</p></li>
</ul>


<p>你还可以根据应用的具体需求设置<code>UIScrollView</code>的一些显示效果，比如：是否显示水平和竖直方向的滚动条、滚动的弹性效果、缩放的弹性效果，以及允许的滚动方向等。</p>

<p>接下来我们将在代码中创建一个<code>UIScrollView</code>。在下载的资源文件中打开<code>ScrollViewDemo</code>工程。它就是一个简单的<code>Single View Application</code>工程，只不过将<code>storyboard</code>中根控制器的类型绑定为自己新建的叫做<code>ScrollViewController</code>的控制器，还在项目中添加了一张我们要用到的图片，图片名称为<code>image.png</code>。</p>

<p>接下来打开<code>ScrollViewController.swift</code>文件，添加如下代码。</p>

<pre><code class="objc">var scrollView: UIScrollView!
var imageView: UIImageView!
</code></pre>

<p>按如下代码所示修改<code>viewDidLoad()</code>方法。</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    imageView = UIImageView(image: UIImage(named: "image.png"))

    scrollView = UIScrollView(frame: view.bounds)
    scrollView.backgroundColor = UIColor.blackColor()
    scrollView.contentSize = imageView.bounds.size
    scrollView.autoresizingMask = UIViewAutoresizing.FlexibleWidth | UIViewAutoresizing.FlexibleHeight

    scrollView.addSubview(imageView)
    view.addSubview(scrollView)
}
</code></pre>

<p>上述代码创建了一个<code>UIScrollView</code>和<code>UIImageView</code>，<code>UIImageView</code>被设置为<code>UIScrollView</code>的子视图。<code>contentSize</code>属性控制滚动区域的大小，我们将它设置为跟图片的尺寸一样大（2000×1500）。我们将滚动视图的背景色设置为黑色，这样图片就像在一块黑色幕布上滚动一样。我们将滚动视图的<code>autoresizingMask</code>属性设置为<code>.FlexibleWidth</code>和<code>.FlexibleHeight</code>，使它能够在设备旋转之后自动适应新的宽度和高度。运行当前应用，你已经可以通过拖拽手势来滚动显示图片了。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image00.png" alt="" /></p>

<p>当你启动应用后，你会发现图片初始显示区域是它左上角的部分。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image01.png" alt="" /></p>

<p>这是因为滚动视图的<code>bounds</code>的起点默认为(0, 0)，代表了左上角。如果你想改变启动后显示的位置，你需要更改滚动视图的<code>bounds</code>的起点。因为这种需求经常被提起，所以<code>UIScrollView</code>专门提供了一个属性<code>contentOffset</code>用来实现这种需求。</p>

<p>在代码中添加如下语句，注意添加在设置autoresizingMask语句之后。</p>

<pre><code>scrollView.contentOffset = CGPoint(x: 1000, y: 450)
</code></pre>

<p>重新运行应用，你会发现一开始就会显示图片的另一部分而不是左上角。你可以通过这种方式来决定程序启动后将要显示的内容。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image02.png" alt="" /></p>

<h2>缩放</h2>

<p>我们已经添加了一个<code>UIScrollView</code>，并且能够让用户通过拖拽来观看尺寸大于屏幕尺寸的内容。相当棒，但如果视图能够缩放的话会带来更好的体验。</p>

<p>要支持缩放功能，你必须为<code>UIScrollView</code>设置一个代理，而且代理必须遵守<code>UIScrollViewDelegate</code>协议，代理还需要实现<code>viewForZoomingInScrollView()</code>方法，该方法返回想要被缩放的视图。</p>

<p>你还应该为缩放设置一个比例，可以通过<code>UIScrollView</code>的<code>minimumZoomScale</code>和<code>maximumZoomScale</code>这两个属性来实现，它们的默认值都是1.0。</p>

<p>按照如下代码更改<code>ScrollViewController</code>的定义：</p>

<pre><code>class ScrollViewController: UIViewController, UIScrollViewDelegate {
</code></pre>

<p>然后添加如下代码：</p>

<pre><code>func viewForZoomingInScrollView(scrollView: UIScrollView) -&gt; UIView? {
    return imageView
}
</code></pre>

<p>接下来在<code>viewDidLoad()</code>方法的最后添加如下代码：</p>

<pre><code>scrollView.delegate = self  
scrollView.minimumZoomScale = 0.1
scrollView.maximumZoomScale = 4.0
scrollView.zoomScale = 1.0
</code></pre>

<p>在上述代码中，我们设置了<code>zoomScale</code>为1.0，然后设置了缩放的最大和最小比例。在程序运行后，会按照图片的原始尺寸显示（因为<code>zonmScale</code>为1.0），当你使用捏合手势来操作图片时，你会发现图片可以被缩放了。我们设置了<code>maximumZoomScale</code>为4.0，所以图片最大只能放大到4倍。你也会发现，图片放大4倍后会变得很模糊，所以接下来我们会把它的缩放比例重新设置为1.0。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image03.png" alt="" /></p>

<p>从上面的图片中我们可以发现，我们之前将<code>minimumZoomScale</code>设置为0.1实在是太小了，屏幕空出了很多空闲的地方。在横屏模式下，空闲的区域看上去更大。我们希望图片能在某一方向上能与屏幕相匹配，让图片既能完全显示，又能尽量减少屏幕的空闲空间。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image04.png" alt="" /></p>

<p>要达到这样的效果，你必须通过图片尺寸和<code>UIScrollView</code>的尺寸来计算最小的缩放比例。</p>

<p>首先在<code>viewDidLoad()</code>方法中删除以下三行代码：</p>

<pre><code>scrollView.minimumZoomScale = 0.1
scrollView.maximumZoomScale = 4.0
scrollView.zoomScale = 1.0
</code></pre>

<p>在控制器类中添加如下方法。在方法中，我们算出图片同<code>UIScrollView</code>的高度和宽度的比值，并将最小缩放比例设置为两者中更小的那个。注意，我们已经删除了<code>maximumZoomScale</code>的设置，所以它的默认值为1.0。</p>

<pre><code>func setZoomScale() {
    let imageViewSize = imageView.bounds.size
    let scrollViewSize = scrollView.bounds.size
    let widthScale = scrollViewSize.width / imageViewSize.width
    let heightScale = scrollViewSize.height / imageViewSize.height

    scrollView.minimumZoomScale = min(widthScale, heightScale)
    scrollView.zoomScale = 1.0
}
</code></pre>

<p>在<code>viewDidLoad()</code>方法最后调用这个方法：</p>

<pre><code>setZoomScale()
</code></pre>

<p>在<code>viewWillLayoutSubviews()</code>方法中也需要调用该方法，这样当用户改变屏幕方向后，图片的尺寸仍然是正确的。</p>

<pre><code>override func viewWillLayoutSubviews() {
    setZoomScale()
}
</code></pre>

<p>运行程序，现在你会发现无论你缩放到多小，图片都会完整显示并且尽量占满剩余的空间。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image05.png" alt="" /></p>

<p>我们可以发现，图片是被定位在屏幕左上角的，我们希望将它放在屏幕中间。</p>

<p>在代码中添加如下方法。</p>

<pre><code>func scrollViewDidZoom(scrollView: UIScrollView) {
        let imageViewSize = imageView.frame.size
        let scrollViewSize = scrollView.bounds.size

        let verticalPadding = imageViewSize.height &lt; scrollViewSize.height ? (scrollViewSize.height - imageViewSize.height) / 2 : 0
        let horizontalPadding = imageViewSize.width &lt; scrollViewSize.width ? (scrollViewSize.width - imageViewSize.width) / 2 : 0

        scrollView.contentInset = UIEdgeInsets(top: verticalPadding, left: horizontalPadding, bottom: verticalPadding, right: horizontalPadding)
    }
</code></pre>

<p>这个方法在缩放的时候就会被调用，它会通知代理<code>UIScrollView</code>的缩放比例发生改变了。在上面的方法中，我们计算了图片在滚动视图中的内间距，从而使图片始终在屏幕的中间。对于上、下方向的内边距，我们首先判断图片视图的高度是否小于滚动视图的高度，如果是就将边距设为两者的差值的一半，否则设为0。水平间距我们采用同样的方式计算。然后通过<code>contentInset</code>属性设置所有方向的内边距，这个属性代表了<code>UIScrollView</code>的内容距离<code>UIScrollView</code>本身四周的距离。</p>

<p>运行程序，你会发现当你缩小图片时，图片始终保持在屏幕的中间。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image06.png" alt="" /></p>

<h2>通过双击来缩放</h2>

<p><code>UIScrollView</code>默认只支持通过捏合手势来实现缩放效果，如果想实现通过双击来缩放，则需要自己做些额外的设置。</p>

<p><code>iOS人机界面指南</code>中介绍了可以通过双击手势来达到缩放的效果。使用双击手势进行缩放需要一定的前提：要缩放的视图只能在最大和最小比例两个固定值之间来回缩放，就像苹果官方的相册应用一样，当你双击图片时，图片放大至最大，当你再次双击时，图片缩小至最小，或者可以通过连续的双击使视图一点点达到最大，然后再次双击的时候，将视图恢复为全屏显示。但是大多数应用需要实现更灵活的双击缩放效果，例如地图应用，当你双击时会使其放大，继续双击会继续放大，想要缩小则可以使用双指捏合手势来实现。</p>

<p>要想在你的程序中实现双击缩放功能，你需要监听<code>UIScrollView</code>的手势并进行处理。在我们的程序中，我们将模仿苹果官方的相册应用的效果，当你双击时放大到最大值，再次双击时则缩小到最小值。</p>

<p>在代码中添加如下两个方法。</p>

<pre><code>func setGestureRecognizer() {
    let doubleTap = UITapGestureRecognizer(target: self, action: "handleDoubleTap:")
    doubleTap.numberOfTapsRequired = 2
    scrollView.addGestureRecognizer(doubleTap)
}

func handleDoubleTap(recognizer: UITapGestureRecognizer) {
    if (scrollView.zoomScale &gt; scrollView.minimumZoomScale) {
        scrollView.setZoomScale(scrollView.minimumZoomScale, animated: true)
    } else {
        scrollView.setZoomScale(scrollView.maximumZoomScale, animated: true)
    }
}
</code></pre>

<p>然后在<code>viewDidLoad()</code>方法最后调用上面的方法。</p>

<pre><code>setGestureRecognizer()
</code></pre>

<p>在上面的代码中，我们为<code>UIScrollView</code>添加了一个双击手势的监听，然后根据图片当前的缩放比例，来判断是将图片放大或者缩小。</p>

<p>运行程序，你会发现已经能通过双击手势来缩放图片了。</p>

<h2>用可视化编程方式创建UIScrollView</h2>

<p>使用<code>storyboard</code>可以实现和我们上面使用代码方式实现的同样的功能，而且更为简单，代码量更少。</p>

<p>在<code>Main.storyboard</code>文件中，拖一个新的视图控制器，并将其设置为初始控制器（既可以将箭头拖到新控制器上，也可以在属性选项卡中选中<code>Is Initial View Controller</code>复选框）。</p>

<p>拖一个<code>UIScrollView</code>到新的控制器中，然后设置其边缘始终粘着屏幕。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image07.png" alt="" /></p>

<p>然后拖一个<code>UIImageView</code>到刚才的<code>UIScrollView</code>中，将它的边缘设置为粘着<code>UIScrollView</code>。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image08.png" alt="" /></p>

<p>要记住<code>UIScrollView</code>需要知道它的内容的大小，才可以实现滚动。当你为<code>UIImageView</code>设置图片时，<code>UIScrollView</code>的内容大小就会被自动设置为图片的大小。</p>

<p>在<code>UIImageView</code>的属性选项卡中，将<code>Image</code>属性设置为<code>image.png</code>，然后通过<code>updating the frames</code>解决自动布局的问题。运行程序，你会发现已经实现图片的滚动显示了，并且没有敲一行代码。你还可以在<code>UIScrollView</code>的属性选项卡中查看还有哪些属性可以设置，比如可以设置最大和最小的缩放比例。</p>

<p>如果想要实现缩放功能，你仍然需要通过代码，设置代理并实现<code>viewForZoomingInScrollView()</code>方法，同我们之前做过的一样，就不再重复一遍了。</p>

<h2>UIScrollView的嵌套使用</h2>

<p>可以在一个<code>UIScrollView</code>中嵌套另一个<code>UIScrollView</code>，两个<code>UIScrollView</code>既可以是相同方向滚动的，也可以是不同方向的。这部分内容的示例代码请使用<code>NestedScrollViews</code>项目。</p>

<h4>相同方向的UIScrollView嵌套</h4>

<p>相同方向的<code>UIScrollView</code>嵌套是指一个<code>UIScrollView</code>，它有另一个<code>UIScrollView</code>作为子控件，并且它们的滚动方向一致。你可以用相同方向的嵌套来实现这样的效果，比如在<code>UIScrollView</code>中添加多组要区分开的数据，你还可以通过它来实现两个<code>UIScrollView</code>同时滚动时的视差效果。在我们的示例中，我们将两个相同方向的<code>UIScrollView</code>设置不同的滚动速度，从而实现滚动时的视差效果。</p>

<p>打开<code>NestedScrollViews</code>项目中的<code>storyboard</code>文件，你将看到两个<code>UIScrollView</code>，分别叫做foreground和background。background里面添加了一个<code>UIImageView</code>，并将图片设置为<code>image.png</code>，foreground里面添加了一些标签和一个作为容器用的<code>UIVIew</code>，这些标签只是为了方便我们观看视图的滚动，容器视图我们将在下一节内容中才用到。</p>

<p>我们的界面这样就算搭建完成了，现在运行程序的话，你会发现只有foreground视图在滚动，而background视图保持不动。接下来我们将要实现background的滚动，并且实现滚动的视差效果。</p>

<p>首先将foreground和background两个<code>UIScrollView</code>连线到控制器，之后代码会如下所示：</p>

<pre><code>@IBOutlet weak var background: UIScrollView!
@IBOutlet weak var foreground: UIScrollView!
</code></pre>

<p>我们需要知道foreground视图滚动了多长的距离，用来计算background视图需要滚动多长的距离。所以我们需要为foreground视图设置一个代理，用来监听它的滚动。</p>

<pre><code>class ViewController: UIViewController, UIScrollViewDelegate {
</code></pre>

<p>在<code>viewDidLoad()</code>方法中设置foreground视图的代理。</p>

<pre><code>foreground.delegate = self
</code></pre>

<p>然后实现如下代理方法。</p>

<pre><code>func scrollViewDidScroll(scrollView: UIScrollView) {
    let foregroundHeight = foreground.contentSize.height - CGRectGetHeight(foreground.bounds)
    let percentageScroll = foreground.contentOffset.y / foregroundHeight
    let backgroundHeight = background.contentSize.height - CGRectGetHeight(background.bounds)

    background.contentOffset = CGPoint(x: 0, y: backgroundHeight * percentageScroll)
}
</code></pre>

<p>在上面的代码中，我们获取了foreground视图可以滚动的最大高度，然后用当前滚动的距离除以它以获取滚动的比例，然后获取background视图可以滚动的最大高度，将其乘以滚动比例，就可以得到background应该滚动的距离。运行你的程序，在进行滚动时你会发现foreground和background两个视图都在滚动，并且background视图滚动的更快，从而有一种视差效果。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/sv01.gif" alt="" /></p>

<h4>交叉方向的UIScrollView嵌套</h4>

<p>交叉方向的<code>UIScrollView</code>嵌套是指一个<code>UIScrollView</code>，它有另一个<code>UIScrollView</code>作为子控件，并且它们的滚动方向正好相差90°，接下来我们就演示一下这种情况。</p>

<p>在<code>NestedScrollViews</code>项目中，你会发现在foreground里面有一个<code>Container View</code>，我们将用它来设置我们水平滚动的<code>UIScrollView</code>。</p>

<p>在<code>storyboard</code>中新拖入一个控制器，按住Control键从<code>Container View</code>拖到新的控制器，选择<em>embed</em>方式。然后选中这个控制器，将它的Size选项设为<em>Freeform</em>并将其高度设为128，因为<code>Container View</code>的高度就是128。</p>

<p>往新控制器中拖入一个<code>UIScrollView</code>，设置其边缘始终粘着父控件。然后在<code>UIScrollView</code>中拖入一个70×70的<code>UIView</code>，将其背景色设为灰色方便我们观看，然后复制多个，从左到右依次摆放在<code>UIScrollView</code>中。你不需要精确地去设置每一个<code>UIView</code>的位置，接下来我会教你们怎么去做。现在我们的控制器界面应该是这个样子。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image12.png" alt="" /></p>

<p>选择最左边的<code>UIView</code>，添加它上边和左边的约束，再添加宽度和高度约束。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image13.png" alt="" /></p>

<p>再选择最右边的<code>UIView</code>，添加它的上边、右边、宽度和高度约束。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/image14.png" alt="" /></p>

<p>接下来，选中我们的<code>UIScrollView</code>，然后点击上面菜单栏中的<code>Editor &gt; Resolve Auto Layout Issues &gt; All Views &gt; Add Missing Constraints</code>。这样我们所有的<code>UIView</code>就都添加好了约束。运行你的程序，竖直滚动到底部，你会看见我们的<code>Container View</code>，你可以水平滚动它里面的内容。下图中，我将控制器自身视图的背景色设置为透明，所以你看到的效果就是这样的。</p>

<p><img src="http://www.appcoda.com/wp-content/uploads/2015/06/sv02.gif" alt="" /></p>

<p>我们的教程这就结束了，并没有包含<code>UIScrollView</code>所有的方方面面，但我希望通过这篇教程可以让你对<code>UIScrollView</code>有初步的了解，更多<code>UIScrollView</code>的知识，你可以查看苹果的官方文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/WindowsViews/Conceptual/UIScrollView_pg/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008179-CH1-SW1">Scroll View Programming Guide</a>。</p>

<p>你可以在<a href="https://www.dropbox.com/s/91buj9d9gmphoen/UIScrollViewFinal.zip?dl=0">这里</a>下载完整的示例程序作为学习参考。（译注：原文资源文件地址需要FQ访问，本人已转存到GitHub上，详见<a href="https://github.com/WXGBridgeQ/UIScrollViewFinal">这里</a>）</p>
]]></content>
  </entry>
  
</feed>
